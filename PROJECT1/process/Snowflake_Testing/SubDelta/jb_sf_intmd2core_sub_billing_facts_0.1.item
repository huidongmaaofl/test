<?xml version="1.0" encoding="UTF-8"?>
<talendfile:ProcessType xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:talendfile="platform:/resource/org.talend.model/model/TalendFile.xsd" defaultContext="Default">
  <context confirmationNeeded="false" name="Default"/>
  <parameters>
    <elementParameter field="TEXT" name="SCREEN_OFFSET_X" value="0"/>
    <elementParameter field="TEXT" name="SCREEN_OFFSET_Y" value="0"/>
    <elementParameter field="TEXT" name="REPOSITORY_CONNECTION_ID" value=""/>
    <elementParameter field="CHECK" name="IMPLICITCONTEXT_USE_PROJECT_SETTINGS" value="true"/>
    <elementParameter field="CHECK" name="STATANDLOG_USE_PROJECT_SETTINGS" value="true"/>
    <elementParameter field="CHECK" name="MULTI_THREAD_EXECATION" value="false"/>
    <elementParameter field="TEXT" name="PARALLELIZE_UNIT_SIZE" value="25000"/>
    <elementParameter field="CHECK" name="IMPLICIT_TCONTEXTLOAD" value="false"/>
    <elementParameter field="RADIO" name="FROM_FILE_FLAG_IMPLICIT_CONTEXT" value="false"/>
    <elementParameter field="RADIO" name="FROM_DATABASE_FLAG_IMPLICIT_CONTEXT" value="false"/>
    <elementParameter field="FILE" name="IMPLICIT_TCONTEXTLOAD_FILE" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="FIELDSEPARATOR" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="PROPERTY_TYPE_IMPLICIT_CONTEXT:PROPERTY_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="PROPERTY_TYPE_IMPLICIT_CONTEXT:REPOSITORY_PROPERTY_TYPE" value=""/>
    <elementParameter field="CLOSED_LIST" name="DB_TYPE_IMPLICIT_CONTEXT" value=""/>
    <elementParameter field="CLOSED_LIST" name="DB_VERSION_IMPLICIT_CONTEXT" value=""/>
    <elementParameter field="TEXT" name="URL_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR_IMPLICIT_CONTEXT"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="HOST_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="PORT_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="DBNAME_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="LOCAL_SERVICE_NAME_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="PROPERTIES_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="SCHEMA_DB_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS_IMPLICIT_CONTEXT" value="0RMsyjmybrE="/>
    <elementParameter field="FILE" name="DBFILE_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="DBTABLE" name="DBTABLE_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="QUERY_CONDITION_IMPLICIT_CONTEXT" value="&quot;&quot;"/>
    <elementParameter field="CLOSED_LIST" name="LOAD_NEW_VARIABLE" value=""/>
    <elementParameter field="CLOSED_LIST" name="NOT_LOAD_OLD_VARIABLE" value=""/>
    <elementParameter field="CHECK" name="PRINT_OPERATIONS" value="false"/>
    <elementParameter field="CHECK" name="DISABLE_ERROR" value="false"/>
    <elementParameter field="CHECK" name="DISABLE_WARNINGS" value="false"/>
    <elementParameter field="CHECK" name="DISABLE_INFO" value="false"/>
    <elementParameter field="CHECK" name="ON_STATCATCHER_FLAG" value="false"/>
    <elementParameter field="CHECK" name="ON_LOGCATCHER_FLAG" value="true"/>
    <elementParameter field="CHECK" name="ON_METERCATCHER_FLAG" value="false"/>
    <elementParameter field="CHECK" name="ON_CONSOLE_FLAG" value="true"/>
    <elementParameter field="CHECK" name="ON_FILES_FLAG" value="false"/>
    <elementParameter field="DIRECTORY" name="FILE_PATH" value="&quot;C:/Talend/5.6.2/studio/workspace/.metadata&quot;"/>
    <elementParameter field="TEXT" name="FILENAME_STATS" value="&quot;stats_file.txt&quot;"/>
    <elementParameter field="TEXT" name="FILENAME_LOGS" value="&quot;logs_file.txt&quot;"/>
    <elementParameter field="TEXT" name="FILENAME_METTER" value="&quot;meter_file.txt&quot;"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="ISO-8859-15"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="CHECK" name="ON_DATABASE_FLAG" value="true"/>
    <elementParameter field="TECHNICAL" name="PROPERTY_TYPE:PROPERTY_TYPE" value="REPOSITORY"/>
    <elementParameter field="TECHNICAL" name="PROPERTY_TYPE:REPOSITORY_PROPERTY_TYPE" value="_BCUy0FT7Eeaxx-GQ_IpdbQ"/>
    <elementParameter field="CLOSED_LIST" name="DB_TYPE" value="tJDBCOutput"/>
    <elementParameter field="CLOSED_LIST" name="DB_VERSION" value="PRIOR_TO_V9"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:snowflake://ageoflearning.snowflakecomputing.com/?role=etl_worker&amp;db=aoflprod&amp;schema=abc_edw_stg&amp;warehouse=abc_etl_wh&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR">
      <elementValue elementRef="JAR_NAME" value="snowflake-jdbc-3.0.11.jar"/>
    </elementParameter>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;net.snowflake.client.jdbc.SnowflakeDriver&quot;"/>
    <elementParameter field="TEXT" name="HOST" value="context.Redshift_Conn_Server"/>
    <elementParameter field="TEXT" name="PORT" value="context.Redshift_Conn_Port"/>
    <elementParameter field="TEXT" name="DATASOURCE" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="DBNAME" value=""/>
    <elementParameter field="TEXT" name="LOCAL_SERVICE_NAME" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="PROPERTIES" value="&quot;noDatetimeStringSync=true&quot;"/>
    <elementParameter field="TEXT" name="SCHEMA_DB" value=""/>
    <elementParameter field="TEXT" name="USER" value="&quot;talend_etl&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="ZWL+OPUW6faJdkOhlz1EnbTCuWuA5Z5cV24ZL5IpQi9kLPN+enSvEQ=="/>
    <elementParameter field="FILE" name="DBFILE" value="&quot;&quot;"/>
    <elementParameter field="DBTABLE" name="TABLE_STATS" value="&quot;&quot;"/>
    <elementParameter field="DBTABLE" name="TABLE_LOGS" value="&quot;abc_edw_meta.AOFL_PROJECT_LOGS&quot;"/>
    <elementParameter field="DBTABLE" name="TABLE_METER" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="CATCH_RUNTIME_ERRORS" value="true"/>
    <elementParameter field="CHECK" name="CATCH_USER_ERRORS" value="true"/>
    <elementParameter field="CHECK" name="CATCH_USER_WARNING" value="true"/>
    <elementParameter field="CHECK" name="CATCH_REALTIME_STATS" value="false"/>
    <elementParameter field="TEXT" name="HEADERFOOTER_HEADERID" value=""/>
    <elementParameter field="CHECK" name="HEADER_ENABLED" value="false"/>
    <elementParameter field="TEXT" name="HEADER_LIBRARY" value=""/>
    <elementParameter field="TEXT" name="HEADER_CODE" value=""/>
    <elementParameter field="TEXT" name="HEADER_IMPORT" value=""/>
    <elementParameter field="TEXT" name="HEADERFOOTER_FOOTERID" value=""/>
    <elementParameter field="CHECK" name="FOOTER_ENABLED" value="false"/>
    <elementParameter field="TEXT" name="FOOTER_LIBRARY" value=""/>
    <elementParameter field="TEXT" name="FOOTER_CODE" value=""/>
    <elementParameter field="TEXT" name="FOOTER_IMPORT" value=""/>
    <routinesParameter id="_UyiNIPX0EeWWKsygvsCDwg" name="DQTechnical"/>
    <routinesParameter id="_pC_O0PVVEeW3v-xk1uty1w" name="DataOperation"/>
    <routinesParameter id="_UvTS8PX0EeWWKsygvsCDwg" name="DataQuality"/>
    <routinesParameter id="_UxN-gPX0EeWWKsygvsCDwg" name="DqStringHandling"/>
    <routinesParameter id="_pEkjMPVVEeW3v-xk1uty1w" name="Mathematical"/>
    <routinesParameter id="_pFyEIPVVEeW3v-xk1uty1w" name="Numeric"/>
    <routinesParameter id="_pHCoYPVVEeW3v-xk1uty1w" name="Relational"/>
    <routinesParameter id="_pNGNEPVVEeW3v-xk1uty1w" name="SQLike"/>
    <routinesParameter id="_pINGAPVVEeW3v-xk1uty1w" name="StringHandling"/>
    <routinesParameter id="_pJam8PVVEeW3v-xk1uty1w" name="TalendDataGenerator"/>
    <routinesParameter id="_pKoH4PVVEeW3v-xk1uty1w" name="TalendDate"/>
    <routinesParameter id="_pL7vcPVVEeW3v-xk1uty1w" name="TalendString"/>
    <routinesParameter id="_FL47UNKuEeKnXdHKUaxwnQ" name="CheckZip"/>
    <routinesParameter id="_xFoiYOSuEeKgRuMsU-Aatw" name="GeoLocationCalculation"/>
    <routinesParameter id="_fxLlYMqZEeW_Wu7kq_dgpA" name="HtmlGeneration2"/>
    <routinesParameter id="_Yql8wKjlEeWukotDNJTWbg" name="HtmlGeneration"/>
    <routinesParameter id="_9aoGcKT9EeW80p8IK1FyUQ" name="QuerySplitter"/>
    <routinesParameter id="_u4W7IJJjEea7f4xH-7-lGA" name="compressFiles_in_GZIP_Format"/>
    <routinesParameter id="_FL47UNKuEeKnXdHKUaxwnQ" name="CheckZip"/>
    <routinesParameter id="_xFoiYOSuEeKgRuMsU-Aatw" name="GeoLocationCalculation"/>
    <routinesParameter id="_fxLlYMqZEeW_Wu7kq_dgpA" name="HtmlGeneration2"/>
    <routinesParameter id="_Yql8wKjlEeWukotDNJTWbg" name="HtmlGeneration"/>
    <routinesParameter id="_9aoGcKT9EeW80p8IK1FyUQ" name="QuerySplitter"/>
  </parameters>
  <node componentName="tJava" componentVersion="0.101" offsetLabelX="0" offsetLabelY="0" posX="256" posY="32">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_1"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="MEMO_JAVA" name="CODE" value="System.out.println(&quot;Job &quot; + jobName + &quot; is going to start to do subs delta changes on account history.&quot;);"/>
    <elementParameter field="MEMO_IMPORT" name="IMPORT" value="//import java.util.List;"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJava_1"/>
  </node>
  <node componentName="tJDBCConnection" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="64" posY="160">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCConnection_1"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="TECHNICAL" name="PROPERTY:PROPERTY_TYPE" value="REPOSITORY"/>
    <elementParameter field="TECHNICAL" name="PROPERTY:REPOSITORY_PROPERTY_TYPE" value="_BCUy0FT7Eeaxx-GQ_IpdbQ"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:snowflake://ageoflearning.snowflakecomputing.com/?role=etl_worker&amp;db=aoflprod&amp;schema=abc_edw_stg&amp;warehouse=abc_etl_wh&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR">
      <elementValue elementRef="JAR_NAME" value="snowflake-jdbc-3.0.11.jar"/>
    </elementParameter>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;net.snowflake.client.jdbc.SnowflakeDriver&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;talend_etl&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="ZWL+OPUW6faJdkOhlz1EnbTCuWuA5Z5cV24ZL5IpQi9kLPN+enSvEQ=="/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="CHECK" name="USE_SHARED_CONNECTION" value="false"/>
    <elementParameter field="TEXT" name="SHARED_CONNECTION_NAME" value=""/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="IS_USE_AUTO_COMMIT" value="true"/>
    <elementParameter field="CHECK" name="AUTO_COMMIT" value="true"/>
    <elementParameter field="TEXT" name="LABEL" value="snowflake"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
  </node>
  <node componentName="tJava" componentVersion="0.101" offsetLabelX="0" offsetLabelY="0" posX="256" posY="160">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_2"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="MEMO_JAVA" name="CODE" value="//Instantiate global params&#xA;globalMap.put(&quot;meta&quot;,&quot;abc_edw_meta&quot;);&#xA;globalMap.put(&quot;land&quot;,&quot;abc_edw_land&quot;);&#xA;globalMap.put(&quot;stg&quot;,&quot;abc_edw_stg&quot;);&#xA;globalMap.put(&quot;core&quot;,&quot;abc_edw_core&quot;);"/>
    <elementParameter field="MEMO_IMPORT" name="IMPORT" value="//import java.util.List;"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJava_2"/>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="64" posY="288">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_1"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;INSERT INTO &quot;+globalMap.get(&quot;meta&quot;)+&quot;.etl_job_log&#xD;&#xA;(&#xD;&#xA;   run_id,&#xD;&#xA;   job_id,&#xD;&#xA;   start_time,&#xD;&#xA;   job_name,&#xD;&#xA;   job_type,&#xD;&#xA;   job_status,&#xD;&#xA;   created_ts,&#xD;&#xA;   created_by,&#xD;&#xA;   last_updated_ts,&#xD;&#xA;   last_updated_by&#xD;&#xA;)&#xD;&#xA;SELECT&#xD;&#xA;  coalesce(last_row.run_id, 0) + 1 as run_id,&#xD;&#xA;  coalesce(last_row.job_id, 1) as job_id,&#xD;&#xA;  to_timestamp_ntz(CURRENT_TIMESTAMP()) as start_time,&#xD;&#xA;  '&quot;+jobName+&quot;' as job_name,&#xD;&#xA;  'sub_dim_load' as job_type,&#xD;&#xA;  'BUSY' as job_status,&#xD;&#xA;  to_timestamp_ntz(CURRENT_TIMESTAMP()) as created_ts,&#xD;&#xA;  '&quot;+jobName+&quot;' as created_by,&#xD;&#xA;  to_timestamp_ntz(CURRENT_TIMESTAMP()) as last_updated_ts,&#xD;&#xA;  '&quot;+jobName+&quot;' as last_updated_by&#xD;&#xA;FROM&#xD;&#xA;(select * from&#xD;&#xA;    (select *, row_number() over (partition by job_name order by start_time desc)as rn&#xD;&#xA;    from&#xD;&#xA;      (select run_id, start_time, job_id, job_name from &quot;+globalMap.get(&quot;meta&quot;)+&quot;.etl_job_log where job_name = '&quot;+jobName+&quot;' &#xD;&#xA;        union&#xD;&#xA;       select 0, '1970-01-01 00:00:00':: timestamp, 0, '&quot;+jobName+&quot;'  &#xD;&#xA;      )&#xD;&#xA;     )&#xD;&#xA;     where rn = 1 &#xD;&#xA;  )&#xD;&#xA;  last_row&#xD;&#xA;;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="Insert etl_job_log"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_1"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="288">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_2"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;DELETE FROM &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_activity&#xD;&#xA;USING &#xD;&#xA;(select -- look for rows inserted in the intermediate table after the last run of this fact table&#xD;&#xA;    'abcmouse' || f.account_domain as del_account_domain, f.account_hist_id as del_account_hist_id, f.created_ts&#xD;&#xA;from &#xD;&#xA;    &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity f &#xD;&#xA;where -- this will also delete the activities changed to is_deleted in the last run of the intermediate table &#xD;&#xA;    f.created_ts > (select coalesce(max(created_ts), '1970-01-01'::timestamp) from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_activity)&#xD;&#xA;)del&#xD;&#xA;WHERE&#xD;&#xA;   del.del_account_domain = account_domain and&#xD;&#xA;   del.del_account_hist_id = account_hist_id&#xD;&#xA;; &#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="delete&lt;br>f_subscriber_activity"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_2"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="416" posY="288">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_3"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;insert into &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_activity&#xD;&#xA;&#xD;&#xA;SELECT distinct&#xD;&#xA;    coalesce(d_f.family_key, 0) as family_key,&#xD;&#xA;    coalesce(d_d.domain_key, 0) as domain_key,&#xD;&#xA;    coalesce(d_aa.account_activity_key, 0) as account_activity_key,&#xD;&#xA;    coalesce(d_dt.date_key, 0) as activity_date_key,&#xD;&#xA;    coalesce(d_p.product_key, 0) as product_key,&#xD;&#xA;    coalesce(d_sg.subscription_group_key, 0) as subscription_group_key,&#xD;&#xA;    coalesce(brg_s.subscription_metric_group_key, 0) as subscription_metric_group_key,&#xD;&#xA;    coalesce(brg_b.billing_metric_group_key, 0) as billing_metric_group_key,&#xD;&#xA;    coalesce(d_at.account_type_key, 0) as account_type_key,&#xD;&#xA;    coalesce(d_ac.acquisition_channel_key, 0) as acquisition_channel_key,&#xD;&#xA;    coalesce(d_as.acquisition_source_key, 0) as acquisition_source_key,&#xD;&#xA;    coalesce(d_dh.device_hierarchy_key, 0) as acquisition_device_hierarchy_key,&#xD;&#xA;    coalesce(d_ti.transaction_info_key, 0) as transaction_info_key,&#xD;&#xA;    coalesce(d_to.transaction_outcome_key, 0) as transaction_outcome_key,&#xD;&#xA;    coalesce(d_cc.transaction_cc_type_key, 0) as transaction_cc_type_key,&#xD;&#xA;    stg.payer_id,&#xD;&#xA;    stg.account_domain,&#xD;&#xA;    stg.account_hist_id,&#xD;&#xA;    stg.activity_id,&#xD;&#xA;    stg.activity_year_month,&#xD;&#xA;    stg.activity_datetime,&#xD;&#xA;    stg.product_id,&#xD;&#xA;    stg.subscription_group,&#xD;&#xA;    stg.subscription_metric_group_name,&#xD;&#xA;    stg.billing_metric_group_name,&#xD;&#xA;    stg.account_type,&#xD;&#xA;    stg.acquisition_channel,&#xD;&#xA;    stg.acquisition_source,&#xD;&#xA;    stg.acquisition_user_agent,&#xD;&#xA;    stg.trx_reason,&#xD;&#xA;    stg.trx_payment_type,&#xD;&#xA;    stg.trx_result,&#xD;&#xA;    stg.trx_cc_type,&#xD;&#xA;    stg.trx_hist_id,&#xD;&#xA;    stg.trx_datetime,&#xD;&#xA;    stg.trx_voided_datetime,&#xD;&#xA;    stg.trx_settled_datetime,&#xD;&#xA;    stg.is_paying_activity,&#xD;&#xA;    stg.is_voided_trx,&#xD;&#xA;    stg.is_settled_trx,&#xD;&#xA;    stg.is_unknown_account,&#xD;&#xA;    null::float8 as amount,  -- V8 null for now, better than an unusable amount&#xD;&#xA;    to_timestamp_ntz(CURRENT_TIMESTAMP()) as created_ts,&#xD;&#xA;    '&quot;+jobName+&quot;'  as created_by &#xD;&#xA;FROM&#xD;&#xA;    (SELECT&#xD;&#xA;        payer_id,&#xD;&#xA;        'abcmouse' || account_domain as account_domain,&#xD;&#xA;        account_hist_id,&#xD;&#xA;        activity_id,  &#xD;&#xA;        activity_day, &#xD;&#xA;        activity_year_month, &#xD;&#xA;        activity_date as activity_datetime,  &#xD;&#xA;        product_id,&#xD;&#xA;        subscription_group,&#xD;&#xA;        subscription_metric_group_name,&#xD;&#xA;        billing_metric_group_name,&#xD;&#xA;        account_type,&#xD;&#xA;        acquisition_channel,&#xD;&#xA;        acquisition_source,&#xD;&#xA;        acquisition_user_agent,&#xD;&#xA;        trx_reason,&#xD;&#xA;        trx_processor,&#xD;&#xA;        trx_updater,&#xD;&#xA;        trx_payment_type,&#xD;&#xA;        trx_result,&#xD;&#xA;        trx_error_code,&#xD;&#xA;        trx_cc_type,&#xD;&#xA;        trx_history_id as trx_hist_id,&#xD;&#xA;        trx_date as trx_datetime,&#xD;&#xA;        trx_voided_date as trx_voided_datetime,&#xD;&#xA;        trx_settled_date  as trx_settled_datetime,&#xD;&#xA;        case when is_paying_event = 1 then true else false end as is_paying_activity,&#xD;&#xA;        case when trx_voided = 1 then true else false end as is_voided_trx,&#xD;&#xA;        case when trx_settled_date is not null then true else false end as is_settled_trx,&#xD;&#xA;        case when is_unknown_account = 1 then true else false end as is_unknown_account,&#xD;&#xA;        -- V8 need to combine trx_amount, activity_price in a meaningful way&#xD;&#xA;        trx_amount,&#xD;&#xA;        activity_price       &#xD;&#xA;    FROM&#xD;&#xA;        &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity i &#xD;&#xA;    WHERE -- select the latest inserts from the intermediate table that are not marked as deleted and the data is relevant to subscription or billing&#xD;&#xA;        i.created_ts > (select coalesce(max(created_ts), '1970-01-01'::timestamp)  from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_activity) and&#xD;&#xA;        i.is_deleted = 0 and&#xD;&#xA;        (i.subscription_group is not null or&#xD;&#xA;        i.subscription_metric_group_name is not null or&#xD;&#xA;        i.billing_metric_group_name is not null)&#xD;&#xA;    )stg&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_family d_f                       ON d_f.parentid = stg.payer_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_domain d_d                       ON d_d.domain_name = stg.account_domain&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_activity d_aa            ON d_aa.account_activity_id = stg.activity_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt                        ON d_dt.fulldate = stg.activity_day&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p                      ON d_p.product_id = stg.product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_subscription_group d_sg          ON d_sg.subscription_group = stg.subscription_group&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_type d_at                ON d_at.account_type_id = stg.account_type&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_channel d_ac         ON d_ac.acquisition_channel_name = stg.acquisition_channel&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_source d_as          ON d_as.acquisition_source_name = stg.acquisition_source&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_transaction_cc_type d_cc         ON d_cc.trx_cc_type = stg.trx_cc_type&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_transaction_info d_ti            &#xD;&#xA;ON &#xD;&#xA;    d_ti.trx_reason = stg.trx_reason and&#xD;&#xA;    d_ti.trx_processor = stg.trx_processor and&#xD;&#xA;    d_ti.trx_updater = stg.trx_updater and&#xD;&#xA;    d_ti.trx_payment_type = stg.trx_payment_type&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_transaction_outcome d_to     &#xD;&#xA;ON &#xD;&#xA;    d_to.trx_result = stg.trx_result and&#xD;&#xA;    d_to.trx_error_code = stg.trx_error_code &#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select max(device_hierarchy_key) as device_hierarchy_key, custom_user_agent from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_device_hierarchy group by custom_user_agent) d_dh        &#xD;&#xA;ON &#xD;&#xA;    d_dh.custom_user_agent = stg.acquisition_user_agent   &#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select distinct subscription_metric_group_key, subscription_metric_group_name from &quot;+globalMap.get(&quot;core&quot;)+&quot;.brg_subscription_metric_group) brg_s  &#xD;&#xA;ON &#xD;&#xA;    brg_s.subscription_metric_group_name = stg.subscription_metric_group_name&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select distinct billing_metric_group_key, billing_metric_group_name from &quot;+globalMap.get(&quot;core&quot;)+&quot;.brg_billing_metric_group) brg_b       &#xD;&#xA;ON &#xD;&#xA;    brg_b.billing_metric_group_name = stg.billing_metric_group_name&#xD;&#xA;ORDER BY&#xD;&#xA;    payer_id, &#xD;&#xA;    domain_key, &#xD;&#xA;    activity_datetime, &#xD;&#xA;    subscription_group_key, &#xD;&#xA;    subscription_metric_group_key, &#xD;&#xA;    billing_metric_group_key&#xD;&#xA;;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="insert &lt;br>f_subscriber_activity"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_3"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="416">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_4"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;DELETE FROM  &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_status;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="delete&lt;br>f_subscriber_status"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_4"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="416" posY="416">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_5"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;--Snowflake Status&#xD;&#xA;insert into &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_status&#xD;&#xA;&#xD;&#xA;SELECT &#xD;&#xA;   coalesce(d_f.family_key, 0) as family_key,&#xD;&#xA;   coalesce(d_d.domain_key, 0) as domain_key,&#xD;&#xA;   coalesce(d_dt_ac.date_key, 0) as account_created_date_key,&#xD;&#xA;   coalesce(d_dt_sub.date_key, 0) as subscription_date_key,    &#xD;&#xA;   coalesce(d_dt_exp_act.date_key, 0) as expected_activation_date_key,&#xD;&#xA;   coalesce(d_dt_act.date_key, 0) as activation_date_key,&#xD;&#xA;   coalesce(d_dt_f_upg.date_key, 0) as first_upgrade_date_key,&#xD;&#xA;   coalesce(d_dt_l_upg.date_key, 0) as last_upgrade_date_key,&#xD;&#xA;   coalesce(d_dt_l_react.date_key, 0) as last_reactivation_date_key,&#xD;&#xA;   coalesce(d_dt_l_deact.date_key, 0) as last_deactivation_date_key,&#xD;&#xA;   coalesce(d_dt_term.date_key, 0) as termination_date_key,   -- v8 changed from last_termination_date_key&#xD;&#xA;   coalesce(d_dt_l_act.date_key, 0) as last_activity_date_key,&#xD;&#xA;   coalesce(d_dt_l_nbd.date_key, 0) as last_recorded_next_billing_date_key,&#xD;&#xA;   coalesce(d_dt_nbd.date_key, 0) as next_billing_date_key,&#xD;&#xA;   coalesce(d_sg.subscription_group_key, 0) as subscription_group_key,&#xD;&#xA;   coalesce(d_p_sub.product_key, 0) as subscription_product_key,&#xD;&#xA;   coalesce(d_p_last.product_key, 0) as last_recorded_product_key,&#xD;&#xA;   coalesce(d_at.account_type_key, 0) as account_type_key,&#xD;&#xA;   coalesce(d_ac.acquisition_channel_key, 0) as acquisition_channel_key,&#xD;&#xA;   coalesce(d_as.acquisition_source_key, 0) as acquisition_source_key,&#xD;&#xA;   coalesce(d_dh.device_hierarchy_key, 0) as acquisition_device_hierarchy_key,&#xD;&#xA;   coalesce(d_cs.cohort_key, 0) as cohort_subscription_month_key,&#xD;&#xA;   coalesce(d_ca.cohort_key, 0) as cohort_activation_month_key,&#xD;&#xA;   stg.* &#xD;&#xA;FROM &#xD;&#xA;(SELECT -- stg sub-query&#xD;&#xA;        grp.payer_id,&#xD;&#xA;        grp.account_domain,&#xD;&#xA;        grp.account_created_date,&#xD;&#xA;        grp.subscription_datetime,&#xD;&#xA;        grp.expected_activation_datetime,&#xD;&#xA;        grp.activation_datetime,&#xD;&#xA;        grp.first_upgrade_datetime,&#xD;&#xA;        grp.last_upgrade_datetime,&#xD;&#xA;        grp.last_reactivation_datetime,&#xD;&#xA;        grp.last_deactivation_datetime,&#xD;&#xA;        case -- V8 make termination date be null if superseeded by an active date&#xD;&#xA;           when grp.last_termination_datetime &lt; grp.subscription_datetime or&#xD;&#xA;                grp.last_termination_datetime &lt; grp.activation_datetime or &#xD;&#xA;                grp.last_termination_datetime &lt; grp.last_reactivation_datetime then null&#xD;&#xA;           else grp.last_termination_datetime&#xD;&#xA;        end as termination_datetime,&#xD;&#xA;        grp.last_activity_datetime,&#xD;&#xA;        grp.last_recorded_next_billing_datetime,&#xD;&#xA;        case --V8 make next_billing_date be null for inactive subscriber&#xD;&#xA;            when grp.is_currently_paying or grp.is_in_active_trial then&#xD;&#xA;                case -- V8 output the computed next renewal date when nothing else is available&#xD;&#xA;                    when grp.last_recorded_next_billing_datetime is null or &#xD;&#xA;                   grp.last_recorded_next_billing_datetime &lt; grp.last_expected_renewal_day &#xD;&#xA;                    then grp.last_expected_renewal_day&#xD;&#xA;                    else grp.last_recorded_next_billing_datetime&#xD;&#xA;                end    &#xD;&#xA;            else null&#xD;&#xA;        end as next_billing_datetime,&#xD;&#xA;        grp.subscription_group,&#xD;&#xA;        grp.subscription_product_id,&#xD;&#xA;        grp.last_recorded_product_id,&#xD;&#xA;        grp.account_type,&#xD;&#xA;        grp.acquisition_channel,&#xD;&#xA;        grp.acquisition_source,&#xD;&#xA;        grp.acquisition_user_agent,&#xD;&#xA;        grp.subscription_year_month,&#xD;&#xA;        grp.activation_year_month,&#xD;&#xA;        grp.is_in_active_trial,&#xD;&#xA;        grp.is_currently_paying,&#xD;&#xA;        case when grp.is_in_active_trial = true or grp.is_currently_paying = true then true else false end as is_active,&#xD;&#xA;        grp.is_unknown_account,&#xD;&#xA;        case -- V8 when subscription date does not exist (some iTunes accounts or incentivized), the activation counts as a subscription&#xD;&#xA;         when grp.num_subscriptions = 0 and grp.subscription_datetime is not null then 1 &#xD;&#xA;         else grp.num_subscriptions &#xD;&#xA;        end as num_subscriptions,&#xD;&#xA;        grp.num_activations,&#xD;&#xA;        grp.num_upgrades as num_upgrades,&#xD;&#xA;        grp.num_reactivations as num_reactivations,&#xD;&#xA;        grp.num_deactivations as num_deactivations,&#xD;&#xA;        datediff(month, grp.subscription_datetime, dateadd(day, 1, grp.last_activity_datetime))  as months_since_subscription,  -- V8 add one day to last activity date to make the difference inclusive&#xD;&#xA;        datediff(month, grp.activation_datetime, dateadd(day, 1, last_activity_datetime))  as months_since_activation,&#xD;&#xA;        datediff(day, grp.subscription_datetime, dateadd(day, 1, last_activity_datetime)) as days_since_subscription,&#xD;&#xA;        datediff(day, grp.activation_datetime, dateadd(day, 1, last_activity_datetime)) as days_since_activation,&#xD;&#xA;        null::int as active_months_since_subscription,  -- V8 filled by an update process below&#xD;&#xA;        null::int as active_months_since_activation,    -- V8 filled by an update process below&#xD;&#xA;        null::int as active_days_since_subscription,  -- V8 filled by an update process below&#xD;&#xA;        null::int as active_days_since_activation,    -- V8 filled by an update process below&#xD;&#xA;         to_timestamp_ntz(CURRENT_TIMESTAMP()) as created_ts,&#xD;&#xA;        '&quot;+jobName+&quot;' as created_by&#xD;&#xA;FROM&#xD;&#xA;        (SELECT   -- grp sub-query&#xD;&#xA;         stg_all.payer_id,&#xD;&#xA;         stg_all.account_domain,&#xD;&#xA;         max(stg_all.account_created_date) as account_created_date,&#xD;&#xA;         max(stg_all.subscription_datetime) as subscription_datetime,&#xD;&#xA;         max(stg_all.expected_activation_datetime) as expected_activation_datetime,&#xD;&#xA;         max(stg_all.activation_datetime) as activation_datetime,&#xD;&#xA;         max(stg_all.first_upgrade_datetime) as first_upgrade_datetime,&#xD;&#xA;         max(stg_all.last_upgrade_datetime) as last_upgrade_datetime,&#xD;&#xA;         max(stg_all.last_reactivation_datetime) as last_reactivation_datetime,&#xD;&#xA;         max(stg_all.last_deactivation_datetime) as last_deactivation_datetime,&#xD;&#xA;         max(stg_all.last_termination_datetime) as last_termination_datetime,&#xD;&#xA;         max(stg_all.last_activity_datetime) as last_activity_datetime,&#xD;&#xA;         max(stg_all.last_recorded_next_billing_datetime) as last_recorded_next_billing_datetime,&#xD;&#xA;         max(stg_all.last_expected_renewal_day) as last_expected_renewal_day,&#xD;&#xA;         max(stg_all.subscription_group) as subscription_group,&#xD;&#xA;         max(stg_all.subscription_product_id) as subscription_product_id,&#xD;&#xA;         max(stg_all.last_recorded_product_id) as last_recorded_product_id,&#xD;&#xA;         max(stg_all.account_type) as account_type,&#xD;&#xA;         max(stg_all.acquisition_channel) as acquisition_channel,&#xD;&#xA;         max(stg_all.acquisition_source) as acquisition_source,&#xD;&#xA;         max(stg_all.acquisition_user_agent) as acquisition_user_agent,&#xD;&#xA;         max(stg_all.subscription_year_month) as subscription_year_month,&#xD;&#xA;         max(stg_all.activation_year_month) as activation_year_month,&#xD;&#xA;         case when max(stg_all.is_in_active_trial) = 1 then true else false end as is_in_active_trial,&#xD;&#xA;         case when max(stg_all.is_currently_paying) = 1 then true else false end as is_currently_paying,&#xD;&#xA;         case when max(stg_all.is_unknown_account) = 1 then true else false end as is_unknown_account,&#xD;&#xA;         sum(stg_all.subscription_activity) as num_subscriptions,&#xD;&#xA;         max(stg_all.num_activations) as num_activations, -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;         sum(stg_all.upgrade_activity) as num_upgrades,&#xD;&#xA;         max(stg_all.num_activations) - 1 as num_reactivations,  -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;         max(stg_all.num_deactivations) as num_deactivations,    -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;         max(stg_all.max_stg_activity_day) as max_stg_activity_day&#xD;&#xA;        FROM&#xD;&#xA;            (SELECT  -- stg_all sub-query&#xD;&#xA;                i.payer_id,&#xD;&#xA;                'abcmouse' || i.account_domain as account_domain,&#xD;&#xA;                i.account_created_date,&#xD;&#xA;                coalesce(i_sub.activity_date, i_act.activity_date) as subscription_datetime, -- original subscription date&#xD;&#xA;                case &#xD;&#xA;                   when i_sub.trial_term = 0 or i_sub.is_incentivized_subscription = 1 then i_sub.activity_date -- no trial or V9 incentivized&#xD;&#xA;                   when i_sub.trial_term = 1 then dateadd('day', i_sub.trial_period, i_sub.activity_date)  -- trial in days&#xD;&#xA;                   when i_sub.trial_term = 2 then dateadd('week', i_sub.trial_period, i_sub.activity_date)  -- trial in weeks&#xD;&#xA;                   when i_sub.trial_term = 3 then dateadd('month', i_sub.trial_period, i_sub.activity_date)  -- trial in months&#xD;&#xA;                end as expected_activation_datetime,&#xD;&#xA;                i_act.activity_date as activation_datetime, -- original activation date&#xD;&#xA;                i_first_upg.activity_date as first_upgrade_datetime,  -- original upgrade date&#xD;&#xA;                case when i.subscription_metric_group_name like '%~UPG~%' then i.activity_date else null end as last_upgrade_datetime, -- latest upgrade activity date&#xD;&#xA;                case -- V16 use changes in values of the is_paid flag to count activations and deactivations  &#xD;&#xA;                   when i_act_deact.num_activations > 1 then i_act_deact.last_activation_date &#xD;&#xA;                   else null &#xD;&#xA;                end as last_reactivation_datetime,&#xD;&#xA;                i_act_deact.last_deactivation_date as last_deactivation_datetime, -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;                i.termination_date as last_termination_datetime, &#xD;&#xA;                i.activity_date as last_activity_datetime,&#xD;&#xA;                i_last_bill_dt.next_billing_date as last_recorded_next_billing_datetime,&#xD;&#xA;                i_sub.subscription_group,&#xD;&#xA;                i_sub.product_id as subscription_product_id,&#xD;&#xA;                i_last_vals.product_id as last_recorded_product_id,&#xD;&#xA;                i_last_at.account_type,&#xD;&#xA;                i_last_vals.acquisition_channel,&#xD;&#xA;                i_last_vals.acquisition_source,&#xD;&#xA;                i_last_vals.acquisition_user_agent,&#xD;&#xA;                i_sub.activity_year_month as subscription_year_month,&#xD;&#xA;                i_act.activity_year_month as activation_year_month,&#xD;&#xA;                i_last_vals.is_in_active_trial,  -- V8 use the intermediate table column directly&#xD;&#xA;                i_last_renew.next_renewal_or_termination_forward_day as last_expected_renewal_day, -- V10 use the pre-computed field in intmd_f_sub_billing_activity&#xD;&#xA;                case &#xD;&#xA;                   when i_last_renew.next_renewal_or_termination_forward_day &lt; max_stg.activity_day then 0 -- V10 use pre-computed field; V8 some accounts have incomplete data&#xD;&#xA;                   else i_last_renew.is_paid -- V10 change source for is_paid&#xD;&#xA;                end as is_currently_paying,  -- V8 use the intermediate table column directly&#xD;&#xA;                i.is_unknown_account,&#xD;&#xA;                case when subscription_metric_group_name like '%~SUB~%' then 1 else 0 end as subscription_activity,&#xD;&#xA;                case when subscription_metric_group_name like '%~UPG~%' then 1 else 0 end as upgrade_activity,&#xD;&#xA;                i_act_deact.num_activations, -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;                i_act_deact.num_deactivations, -- V16 use changes in values of the is_paid flag to count activations and deactivations&#xD;&#xA;                max_stg.activity_day as max_stg_activity_day&#xD;&#xA;           FROM&#xD;&#xA;                &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity i  &#xD;&#xA;           INNER JOIN --CROSS JOIN&#xD;&#xA;                (select max(activity_day) as activity_day from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity) max_stg on 1=1    &#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from --4,906,558&#xD;&#xA;                (select -- get earliest subscription activity&#xD;&#xA;                     payer_id, account_domain, account_hist_id, activity_date, activity_day, activity_year_month, product_id, trial_term, trial_period, subscription_group,&#xD;&#xA;                     is_incentivized_subscription, -- V9 added&#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date, coalesce(subscription_group, 'ZZZZZZ')) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;                 where&#xD;&#xA;                     subscription_metric_group_name like '%~SUB~%'&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;            )i_sub &#xD;&#xA;           on&#xD;&#xA;                i_sub.payer_id = i.payer_id and &#xD;&#xA;                i_sub.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from  -- 4,102,141&#xD;&#xA;                (select -- get earliest activation activity&#xD;&#xA;                     payer_id, account_domain, account_hist_id, activity_date, activity_day, activity_year_month, product_id, trial_term, trial_period, &#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date, account_hist_id) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;                 where&#xD;&#xA;                     subscription_metric_group_name like '%~ACT~%'&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;           )i_act &#xD;&#xA;           on&#xD;&#xA;                i_act.payer_id = i.payer_id and &#xD;&#xA;                i_act.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from  -- 1,370,292&#xD;&#xA;                (select -- get first upgrade activity&#xD;&#xA;                     payer_id, account_domain, activity_date, activity_day, product_id, trial_term, trial_period, &#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date, account_hist_id) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;                 where&#xD;&#xA;                     subscription_metric_group_name like '%~UPG~%'&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;           )i_first_upg &#xD;&#xA;           on&#xD;&#xA;                i_first_upg.payer_id = i.payer_id and &#xD;&#xA;                i_first_upg.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from  --4,673,009&#xD;&#xA;                (select -- get last non null next billing date, need this because successive next billing dates can go back in time so a max() function can return the wrong results (i.e.switching from annual to monthly)&#xD;&#xA;                     payer_id, account_domain, activity_date, activity_day, &#xD;&#xA;                     case &#xD;&#xA;                        when account_type = 17 then coalesce(account_next_billing_date, activity_next_billing_date) -- third party often miss next billing date &#xD;&#xA;                        else activity_next_billing_date &#xD;&#xA;                     end as next_billing_date, &#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;                 where&#xD;&#xA;                     case &#xD;&#xA;                        when account_type = 17 then coalesce(account_next_billing_date, activity_next_billing_date) -- third party &#xD;&#xA;                        else activity_next_billing_date &#xD;&#xA;                     end is not null&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;           )i_last_bill_dt&#xD;&#xA;           on&#xD;&#xA;                i_last_bill_dt.payer_id = i.payer_id and &#xD;&#xA;                i_last_bill_dt.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from  -- needs to be separated from other last values since some entries may have an account id and no product id&#xD;&#xA;                (select -- get last known values for account type&#xD;&#xA;                     payer_id, account_domain, activity_date, account_type, &#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity&#xD;&#xA;                 where &#xD;&#xA;                     account_type is not null&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;           )i_last_at&#xD;&#xA;           on&#xD;&#xA;                i_last_at.payer_id = i.payer_id and &#xD;&#xA;                i_last_at.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from  -- 5,312,137&#xD;&#xA;                (select -- get last known values for product, channel, source, user agent&#xD;&#xA;                     payer_id, account_domain, activity_date, &#xD;&#xA;                     product_id, acquisition_channel, acquisition_source, acquisition_user_agent, &#xD;&#xA;                     is_in_active_trial, next_renewal_or_termination_forward_day,  -- V10 remove is_paid&#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) as rn  &#xD;&#xA;                 from &#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;                 where &#xD;&#xA;                     coalesce(product_id, 0) &lt;> 0 -- V10 product_id is either null or zero&#xD;&#xA;                     -- acquisition attributes are on all rows of a payer id, if present in the source&#xD;&#xA;                 )&#xD;&#xA;                 where rn = 1&#xD;&#xA;           )i_last_vals&#xD;&#xA;           on&#xD;&#xA;                i_last_vals.payer_id = i.payer_id and &#xD;&#xA;                i_last_vals.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from &#xD;&#xA;                (select  -- V10 get the is_paid value, activity day and expected renwal day for the latest activity (whether we have a product id or not)&#xD;&#xA;                  payer_id, account_domain, activity_day, activity_id, is_paid, next_renewal_or_termination_forward_day,&#xD;&#xA;                  row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) rn&#xD;&#xA;                from &#xD;&#xA;                  &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity &#xD;&#xA;              )where rn = 1&#xD;&#xA;           ) i_last_renew&#xD;&#xA;           ON&#xD;&#xA;                i_last_renew.payer_id = i.payer_id and&#xD;&#xA;                i_last_renew.account_domain = i.account_domain&#xD;&#xA;           LEFT OUTER JOIN  -- V16 get a count of activations and deactivations as well as last activation and deactivation dates for all accounts, based on the changes in values of the is_paid flag &#xD;&#xA;           (select          --     note: this only takes into account explicit deactivations (not the ones created in retention by expired incomplete account histories)&#xD;&#xA;               payer_id,    --     also, an un-activated account will not have a match here (not activation or deactivation dates)&#xD;&#xA;               account_domain,&#xD;&#xA;               sum(is_activation) as num_activations,&#xD;&#xA;               sum(is_deactivation) as num_deactivations,&#xD;&#xA;               max(case when is_activation = 1 then activity_date else null end) as last_activation_date,&#xD;&#xA;               max(case when is_deactivation = 1 then activity_date else null end) as last_deactivation_date&#xD;&#xA;            from&#xD;&#xA;               (select&#xD;&#xA;                   src.payer_id,&#xD;&#xA;                   src.account_domain,&#xD;&#xA;                   src.activity_date,&#xD;&#xA;                   src.is_paid, &#xD;&#xA;                   case when src.is_paid = 1 then 1 else 0 end as is_activation,&#xD;&#xA;                   case when src.is_paid = 0 then 1 else 0 end as is_deactivation,&#xD;&#xA;                   case &#xD;&#xA;                      when src.rn = 1 and src.is_paid = 1 then src.activity_date  -- record activity_date for a direct paying subscription (~SUB~,~ACT~)&#xD;&#xA;                      --when lag(is_paid/* ignore nulls*/) over (partition by payer_id, account_domain order by activity_date, account_hist_id) &lt;> is_paid then activity_date -- otherwise, catch a change in value for the is_paid flag&#xD;&#xA;                      when windows.lag_paid &lt;> src.is_paid then src.activity_date&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;  else null&#xD;&#xA;                   end as switch_activity_date,&#xD;&#xA;                   src.account_hist_id&#xD;&#xA;                from&#xD;&#xA;                   (select &#xD;&#xA;                      payer_id,&#xD;&#xA;                      account_domain,&#xD;&#xA;                      account_hist_id,&#xD;&#xA;                      activity_date,&#xD;&#xA;                      is_paid,&#xD;&#xA;                      row_number() over (partition by payer_id, account_domain order by activity_date, account_hist_id) as rn&#xD;&#xA;                   from&#xD;&#xA;                      &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity&#xD;&#xA;                   where&#xD;&#xA;                      is_deleted = 0&#xD;&#xA;                   ) src&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   left join --windows subquery because of ignore nulls&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   (select payer_id, account_domain, activity_date, account_hist_id, lag_paid from(&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;select src.payer_id, src.account_domain, src.activity_date, src.account_hist_id, lag_paid.is_paid as lag_paid, &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;row_number() over(partition by src.payer_id, src.account_domain, src.activity_date, src.account_hist_id order by lag_paid.activity_date desc, lag_paid.account_hist_id desc) as rn&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;from&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity src&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;left join&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;select payer_id,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_domain,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;account_hist_id,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;activity_date,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is_paid&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;where is_paid is not null&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;)lag_paid&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;on&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lag_paid.payer_id = src.payer_id and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lag_paid.account_domain = src.account_domain and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lag_paid.activity_date &lt; src.activity_date and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lag_paid.account_hist_id &lt; src.account_hist_id&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;order by src.payer_id, src.account_domain, src.activity_date, src.account_hist_id&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;) where rn=1 --keep only most recent value&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   ) windows&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   on windows.payer_id = src.payer_id and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   windows.account_domain = src.account_domain and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   windows.activity_date = src.activity_date and&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;   windows.account_hist_id = src.account_hist_id&#xD;&#xA;                )&#xD;&#xA;                where &#xD;&#xA;                   switch_activity_date is not null&#xD;&#xA;                group by&#xD;&#xA;                   payer_id, account_domain&#xD;&#xA;           ) i_act_deact&#xD;&#xA;           ON&#xD;&#xA;                i_act_deact.payer_id = i.payer_id and&#xD;&#xA;                i_act_deact.account_domain = i.account_domain&#xD;&#xA;           WHERE &#xD;&#xA;                i.is_deleted = 0 and&#xD;&#xA;                (i.subscription_group is not null or&#xD;&#xA;                i.subscription_metric_group_name is not null or&#xD;&#xA;                i.billing_metric_group_name is not null)&#xD;&#xA;        )stg_all&#xD;&#xA;        GROUP BY&#xD;&#xA;         stg_all.payer_id,&#xD;&#xA;         stg_all.account_domain&#xD;&#xA;   )grp&#xD;&#xA;) stg&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_family d_f                       ON d_f.parentid = stg.payer_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_domain d_d                       ON d_d.domain_name = stg.account_domain&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_ac                     ON d_dt_ac.fulldate = stg.account_created_date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_sub                    ON d_dt_sub.fulldate = stg.subscription_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_exp_act                ON d_dt_exp_act.fulldate = stg.expected_activation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_act                    ON d_dt_act.fulldate = stg.activation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_f_upg                  ON d_dt_f_upg.fulldate = stg.first_upgrade_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_l_upg                  ON d_dt_l_upg.fulldate = stg.last_upgrade_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_l_react                ON d_dt_l_react.fulldate = stg.last_reactivation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_l_deact                ON d_dt_l_deact.fulldate = stg.last_deactivation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_term                   ON d_dt_term.fulldate = stg.termination_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_l_act                  ON d_dt_l_act.fulldate = stg.last_activity_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_l_nbd                  ON d_dt_l_nbd.fulldate = stg.last_recorded_next_billing_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_nbd                    ON d_dt_nbd.fulldate = stg.next_billing_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_subscription_group d_sg          ON d_sg.subscription_group = stg.subscription_group&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p_sub                  ON d_p_sub.product_id = stg.subscription_product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p_last                 ON d_p_last.product_id = stg.last_recorded_product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_type d_at                ON d_at.account_type_id = stg.account_type&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_channel d_ac         ON d_ac.acquisition_channel_name = stg.acquisition_channel&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_source d_as          ON d_as.acquisition_source_name = stg.acquisition_source&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_cohort d_cs                      ON d_cs.cohort_year_month_number = stg.subscription_year_month&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_cohort d_ca                      ON d_ca.cohort_year_month_number = stg.activation_year_month&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select max(device_hierarchy_key) as device_hierarchy_key, custom_user_agent from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_device_hierarchy group by custom_user_agent) d_dh        &#xD;&#xA;ON &#xD;&#xA;    d_dh.custom_user_agent = stg.acquisition_user_agent&#xD;&#xA;ORDER BY&#xD;&#xA;    payer_id, &#xD;&#xA;    domain_key, &#xD;&#xA;    subscription_date_key, &#xD;&#xA;    activation_date_key, &#xD;&#xA;    subscription_group_key, &#xD;&#xA;    account_type_key&#xD;&#xA;;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="insert&lt;br>f_subscriber_status"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_5"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="576" posY="416">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_6"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;UPDATE &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_status SET &#xD;&#xA;    active_months_since_subscription = act_days.active_months_since_subscription,  -- V16 rename for clarity&#xD;&#xA;    active_months_since_activation = act_days.active_months_since_activation,      -- V16 rename for clarity&#xD;&#xA;    active_days_since_subscription = act_days.active_days_since_subscription,&#xD;&#xA;    active_days_since_activation = act_days.active_days_since_activation&#xD;&#xA;FROM&#xD;&#xA;(select&#xD;&#xA;   act_months.payer_id,  -- act_days sub-query&#xD;&#xA;   'abcmouse' || act_months.account_domain as account_domain,&#xD;&#xA;   sum(act_months.is_active_month_since_subscription) as active_months_since_subscription,  -- V16 rename for clarity&#xD;&#xA;   sum(act_months.is_active_month_since_activation) as active_months_since_activation,    -- V16 rename for clarity&#xD;&#xA;   sum(act_months.is_active_days_since_subscription) as active_days_since_subscription,  -- V10 corrected typo&#xD;&#xA;   sum(act_months.is_active_days_since_activation) as active_days_since_activation&#xD;&#xA;from&#xD;&#xA;        (SELECT  -- act_months sub-query&#xD;&#xA;           payer_id,&#xD;&#xA;           account_domain,&#xD;&#xA;           year_month_number,&#xD;&#xA;           max(is_active_month_before_activation) + max(is_active_month_on_or_after_activation) as is_active_month_since_subscription, -- V16 add both before and after activation months&#xD;&#xA;           max(is_active_month_on_or_after_activation) as is_active_month_since_activation,  -- V16 rename for clarity&#xD;&#xA;           sum(is_active_day_before_activation) + sum(is_active_day_on_or_after_activation) as is_active_days_since_subscription, -- V10 corrected typo&#xD;&#xA;           sum(is_active_day_on_or_after_activation) as is_active_days_since_activation&#xD;&#xA;        FROM&#xD;&#xA;           (SELECT&#xD;&#xA;              dt_driver.payer_id,&#xD;&#xA;              dt_driver.account_domain,&#xD;&#xA;              dt_driver.fulldate,&#xD;&#xA;              dt_driver.year_month_number,&#xD;&#xA;              case &#xD;&#xA;                 when dt_driver.fulldate &lt; dt_driver.act_activity_day then&#xD;&#xA;                    case &#xD;&#xA;                       when f.activity_year_month is null &#xD;&#xA;                       then last_value(f.is_active_this_month) ignore nulls over (partition by dt_driver.payer_id, dt_driver.account_domain order by dt_driver.fulldate /*rows unbounded preceding*/) &#xD;&#xA;                       else f.is_active_this_month&#xD;&#xA;                    end&#xD;&#xA;                 else 0&#xD;&#xA;              end as is_active_month_before_activation,&#xD;&#xA;              case &#xD;&#xA;                 when dt_driver.fulldate >= dt_driver.act_activity_day then&#xD;&#xA;                    case &#xD;&#xA;                       when f.activity_year_month is null &#xD;&#xA;                       then last_value(f.is_active_this_month) ignore nulls over (partition by dt_driver.payer_id, dt_driver.account_domain order by dt_driver.fulldate /*rows unbounded preceding*/) &#xD;&#xA;                       else f.is_active_this_month&#xD;&#xA;                    end&#xD;&#xA;                 else 0&#xD;&#xA;              end as is_active_month_on_or_after_activation,&#xD;&#xA;              case &#xD;&#xA;                 when dt_driver.fulldate &lt;  dt_driver.act_activity_day then &#xD;&#xA;                    case &#xD;&#xA;                       when f.activity_day is null &#xD;&#xA;                       then last_value(f.is_active) ignore nulls over (partition by dt_driver.payer_id, dt_driver.account_domain order by dt_driver.fulldate /*rows unbounded preceding*/) &#xD;&#xA;                       else f.is_active&#xD;&#xA;                    end&#xD;&#xA;                 else 0&#xD;&#xA;              end as is_active_day_before_activation,&#xD;&#xA;              case &#xD;&#xA;                 when dt_driver.fulldate >=  dt_driver.act_activity_day then &#xD;&#xA;                    case&#xD;&#xA;                       when f.activity_day is null &#xD;&#xA;                       then last_value(f.is_active) ignore nulls over (partition by dt_driver.payer_id, dt_driver.account_domain order by dt_driver.fulldate /*rows unbounded preceding*/) &#xD;&#xA;                       else f.is_active&#xD;&#xA;                    end&#xD;&#xA;                 else 0&#xD;&#xA;              end as is_active_day_on_or_after_activation&#xD;&#xA;           FROM&#xD;&#xA;              (SELECT  -- dt_driver sub-query  1,480,489,372&#xD;&#xA;                 dr.payer_id,&#xD;&#xA;                 dr.account_domain,&#xD;&#xA;                 dr.sub_activity_day,&#xD;&#xA;                 dr.act_activity_day,&#xD;&#xA;                 dt.fulldate,&#xD;&#xA;                 dt.year_month_number&#xD;&#xA;              FROM&#xD;&#xA;                 (SELECT   -- dr sub-query&#xD;&#xA;                    coalesce(f_sub.payer_id, f_act.payer_id) as payer_id,&#xD;&#xA;                    coalesce(f_sub.account_domain,f_act.account_domain) as account_domain,&#xD;&#xA;                    max(case -- in some limited cases the subscription activity is either missing or comes after the activation &#xD;&#xA;                          when f_sub.activity_day is null or f_act.activity_day &lt; f_sub.activity_day &#xD;&#xA;                          then f_act.activity_day&#xD;&#xA;                          else f_sub.activity_day&#xD;&#xA;                       end) as sub_activity_day,&#xD;&#xA;                    max(f_act.activity_day) as act_activity_day,&#xD;&#xA;                    max(f.activity_day) as last_activity_day&#xD;&#xA;                 FROM &#xD;&#xA;                    &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity f  &#xD;&#xA;                 LEFT OUTER JOIN&#xD;&#xA;                 (select * from &#xD;&#xA;                    (select -- select first subscription date&#xD;&#xA;                       payer_id, account_domain, activity_day, &#xD;&#xA;                       row_number() over (partition by payer_id, account_domain order by activity_date, account_hist_id) as rn&#xD;&#xA;                     from &#xD;&#xA;                       &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                     where &#xD;&#xA;                       subscription_metric_group_name like '%~SUB~%'&#xD;&#xA;                     )where rn = 1&#xD;&#xA;                 )f_sub&#xD;&#xA;                 ON&#xD;&#xA;                    f_sub.payer_id = f.payer_id and&#xD;&#xA;                    f_sub.account_domain = f.account_domain&#xD;&#xA;                 LEFT OUTER JOIN&#xD;&#xA;                 (select * from &#xD;&#xA;                    (select -- select first activation date&#xD;&#xA;                       payer_id, account_domain, activity_day, &#xD;&#xA;                       row_number() over (partition by payer_id, account_domain order by activity_date, account_hist_id) as rn&#xD;&#xA;                     from &#xD;&#xA;                       &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                     where &#xD;&#xA;                       subscription_metric_group_name like '%~ACT~%'&#xD;&#xA;                     )where rn = 1&#xD;&#xA;                 ) f_act&#xD;&#xA;                 ON&#xD;&#xA;                    f_act.payer_id = f_sub.payer_id and&#xD;&#xA;                    f_act.account_domain = f_sub.account_domain&#xD;&#xA;                 GROUP BY &#xD;&#xA;                    1, 2&#xD;&#xA;                 )dr&#xD;&#xA;                 CROSS JOIN&#xD;&#xA;                 (select -- layout date rows between the subscriber's active days&#xD;&#xA;                    fulldate,&#xD;&#xA;                    (calendar_year * 100) + month_of_year as year_month_number&#xD;&#xA;                 from&#xD;&#xA;                    &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date&#xD;&#xA;                 where&#xD;&#xA;                    fulldate &lt;= (select max(activity_day) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)   &#xD;&#xA;                 )dt&#xD;&#xA;                 WHERE&#xD;&#xA;                    dt.fulldate between dr.sub_activity_day and dr.last_activity_day&#xD;&#xA;              )dt_driver &#xD;&#xA;           LEFT OUTER JOIN&#xD;&#xA;           (select * from -- 52,759,155&#xD;&#xA;              (select -- select the last activity of each day&#xD;&#xA;                 payer_id, &#xD;&#xA;                 account_domain,&#xD;&#xA;                 activity_day,&#xD;&#xA;                 activity_year_month,&#xD;&#xA;                 case when (is_paid + is_in_active_trial) >= 1 then 1 else 0 end as is_active,  -- V8 use the new is_paid and is_in_active_trial columns&#xD;&#xA;                 max(case when (is_paid + is_in_active_trial) >= 1 then 1 else 0 end) over (partition by payer_id, account_domain, activity_year_month) as is_active_this_month,&#xD;&#xA;                 row_number() over (partition by payer_id, account_domain, activity_day order by activity_date desc, account_hist_id desc) as rn&#xD;&#xA;              from&#xD;&#xA;                 &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;              where -- V8 filter account_item_status activities to the relevant ones (subscription or billing related activities)&#xD;&#xA;                is_deleted = 0  &#xD;&#xA;                -- V16 remove filter as last values for is_paid flag must take every entry into account&#xD;&#xA;              )where rn = 1&#xD;&#xA;           )f&#xD;&#xA;           ON&#xD;&#xA;              f.payer_id = dt_driver.payer_id and&#xD;&#xA;              f.account_domain = dt_driver.account_domain and&#xD;&#xA;              f.activity_day = dt_driver.fulldate&#xD;&#xA;           )&#xD;&#xA;        GROUP BY&#xD;&#xA;           payer_id,&#xD;&#xA;           account_domain,&#xD;&#xA;           year_month_number&#xD;&#xA;        )act_months&#xD;&#xA;GROUP BY&#xD;&#xA;   payer_id,&#xD;&#xA;   account_domain&#xD;&#xA;)act_days&#xD;&#xA;WHERE&#xD;&#xA;    act_days.payer_id = &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_status.payer_id and   &#xD;&#xA;    act_days.account_domain = &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_status.account_domain;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="update&lt;br>f_subscriber_status"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_6"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="544">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_7"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;DELETE FROM  &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="delete&lt;br>f_subscriber_retention"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_7"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="416" posY="544">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_8"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;--Snowflake Retention&#xD;&#xA;insert into &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention&#xD;&#xA;&#xD;&#xA;select&#xD;&#xA;   coalesce(d_f.family_key, 0) as family_key,&#xD;&#xA;   coalesce(d_d.domain_key, 0) as domain_key,&#xD;&#xA;   coalesce(m_vw.first_day_of_month_key, 0) as calendar_month_date_key,&#xD;&#xA;   coalesce(d_sg.subscription_group_key, 0) as subscription_group_key,&#xD;&#xA;   coalesce(d_m_churn.metric_key, 0) as retention_deactivation_metric_key, -- V9 added metric key for deactivation metric&#xD;&#xA;   coalesce(d_m_add.metric_key, 0) as retention_activation_metric_key,     -- V9 added metric key for activation metric&#xD;&#xA;   coalesce(d_at.account_type_key, 0) as account_type_key,&#xD;&#xA;   coalesce(d_p_sub.product_key, 0) as subscription_product_key,&#xD;&#xA;   coalesce(d_p_upg.product_key, 0) as upgrade_product_key,&#xD;&#xA;   coalesce(d_ac.acquisition_channel_key, 0) as acquisition_channel_key,&#xD;&#xA;   coalesce(d_as.acquisition_source_key, 0) as acquisition_source_key,&#xD;&#xA;   coalesce(d_dh.device_hierarchy_key, 0) as acquisition_device_hierarchy_key,&#xD;&#xA;   coalesce(d_dt_ac.date_key, 0) as account_created_date_key,&#xD;&#xA;   coalesce(d_dt_sub.date_key, 0) as subscription_date_key,    &#xD;&#xA;   coalesce(d_dt_act.date_key, 0) as activation_date_key,&#xD;&#xA;   coalesce(d_dt_upg.date_key, 0) as upgrade_date_key,&#xD;&#xA;   coalesce(d_cs.cohort_key, 0) as cohort_subscription_month_key,&#xD;&#xA;   coalesce(d_ca.cohort_key, 0) as cohort_activation_month_key,&#xD;&#xA;   fact.*,&#xD;&#xA;   to_timestamp_ntz(CURRENT_TIMESTAMP()) as created_ts,&#xD;&#xA;   '&quot;+jobName+&quot;' as created_by&#xD;&#xA;from&#xD;&#xA;(select  -- fact sub-query&#xD;&#xA;   pre_fact.payer_id,&#xD;&#xA;   pre_fact.account_domain,&#xD;&#xA;   pre_fact.year_month_number,&#xD;&#xA;   pre_fact.subscription_group,&#xD;&#xA;   case when is_paid_to_retain = 1 and is_paid_retained = 0 then coalesce(pre_fact.retention_deactivation_metric_code,pre_fact.incomplete_hist_misc_churn) else null end as retention_deactivation_metric_code, -- V10 use the fabricated misc churn for incomplete histories&#xD;&#xA;   case when is_paid_to_retain = 0 and is_paid_this_month = 1 then pre_fact.retention_activation_metric_code else null end as retention_activation_metric_code,&#xD;&#xA;   pre_fact.account_type,&#xD;&#xA;   pre_fact.subscription_product_id,&#xD;&#xA;   pre_fact.upgrade_product_id,&#xD;&#xA;   pre_fact.acquisition_channel,&#xD;&#xA;   pre_fact.acquisition_source,&#xD;&#xA;   pre_fact.acquisition_user_agent,&#xD;&#xA;   pre_fact.account_created_date,&#xD;&#xA;   pre_fact.subscription_datetime,&#xD;&#xA;   pre_fact.activation_datetime,&#xD;&#xA;   pre_fact.upgrade_datetime,&#xD;&#xA;   pre_fact.subscription_year_month,&#xD;&#xA;   pre_fact.activation_year_month,&#xD;&#xA;   pre_fact.upgrade_year_month,&#xD;&#xA;   pre_fact.last_activity_year_month,&#xD;&#xA;   pre_fact.billing_period,&#xD;&#xA;   pre_fact.num_payments_received_this_month,&#xD;&#xA;   pre_fact.is_subscription_year_month,&#xD;&#xA;   pre_fact.is_activation_year_month,&#xD;&#xA;   pre_fact.is_upgrade_year_month,&#xD;&#xA;   pre_fact.is_last_activity_year_month,&#xD;&#xA;   pre_fact.is_paid_this_month,&#xD;&#xA;  -- V16 (Matthew) changed paid_to_retain and paid_retained to different sub group logic (leave out based on sub date)&#xD;&#xA;  &#xD;&#xA;   case --V16 FRS Monthly must be subbed before previous month, others can sub during last month (doesn't look at this month)&#xD;&#xA;&#x9; when (pre_fact.subscription_group in ('FRS Monthly Migrators','FRS Monthly No Migrators','FRS iTunes Monthly','FRS iTunes Annual')--V17a FRS iTunes added to mirror FRS Monthly&#xD;&#xA;&#x9; and to_date(pre_fact.subscription_year_month::varchar, 'yyyyMM') = dateadd('month', -1, to_date(pre_fact.year_month_number::varchar, 'yyyyMM')) ) --force date comparisons for first/last month of year&#xD;&#xA;&#x9; --or pre_fact.subscription_year_month = pre_fact.year_month_number --is_paid_to_retain lags to last month, so this is not needed&#xD;&#xA;&#x9; then 0&#xD;&#xA;     else pre_fact.is_paid_to_retain end&#xD;&#xA;&#x9; as is_paid_to_retain,&#xD;&#xA;   &#xD;&#xA;   case --V16 FRS Monthly and FRS iTunes must be subbed before beginning of last month, others must be subbed before beginning of this month&#xD;&#xA;&#x9; when (pre_fact.subscription_group not in ('FRS Monthly Migrators','FRS Monthly No Migrators','FRS iTunes Monthly','FRS iTunes Annual')--V17 added breakouts for iTunes&#xD;&#xA;&#x9; or to_date(pre_fact.subscription_year_month::varchar, 'yyyyMM') &lt; dateadd('month', -1, to_date(pre_fact.year_month_number::varchar, 'yyyyMM')) ) --force date comparisons for first/last month of year&#xD;&#xA;&#x9;-- or pre_fact.subscription_year_month = pre_fact.year_month_number &#xD;&#xA;&#x9; then pre_fact.is_paid_retained &#xD;&#xA;&#x9; else 0 end&#xD;&#xA;&#x9; as is_paid_retained&#xD;&#xA;from &#xD;&#xA;(select -- pre-fact sub query&#xD;&#xA;      driver.*,&#xD;&#xA;      -- V8 to retain: is_paid from the previous month )&#xD;&#xA;      coalesce(lag(driver.is_paid_this_month, 1) over (partition by driver.payer_id, driver.account_domain order by driver.year_month_number), 0) as is_paid_to_retain,&#xD;&#xA;      -- V8 retained: is_paid_this month unless this is the activation month&#xD;&#xA;      case -- V8 incentivized can be activated without being paid yet&#xD;&#xA;        when driver.is_paid_this_month = 0 --or driver.is_activation_year_month = 1 --V17 if SUB_MONTH, then not is_paid_retained&#xD;&#xA;&#x9;&#x9;&#x9;or driver.is_subscription_year_month = 1&#xD;&#xA;&#x9;&#x9;then 0 &#xD;&#xA;        else 1&#xD;&#xA;      end as is_paid_retained&#xD;&#xA;from &#xD;&#xA;  (select -- driver sub-query&#xD;&#xA;     pre_driver.*,&#xD;&#xA;     case -- V9 turn is paid to 0 if the account history is incomplete and the next renewal date is in the past&#xD;&#xA;        when pre_driver.year_month_number > pre_driver.last_activity_year_month and -- the current month is after the last month of activity&#xD;&#xA;             (pre_driver.next_renewal_month &lt; pre_driver.year_month_number or-- and the next renewal date is before the current month of activity&#xD;&#xA;              (pre_driver.next_renewal_month = pre_driver.year_month_number and &#xD;&#xA;              pre_driver.next_renewal_month &lt; pre_driver.last_activity_year_month and pre_driver.is_paid is null)) -- V10 or the original is_paid value is null meaning no activity on the renewal month, as long as this is not the last month of activity&#xD;&#xA;             then 0 &#xD;&#xA;        else tmp_is_paid_this_month &#xD;&#xA;     end as is_paid_this_month,&#xD;&#xA;     case   -- V10 create a misc churn if the account history is incomplete and the next renewal date is in the past, and the current month is not the last month of activity&#xD;&#xA;        when pre_driver.year_month_number > pre_driver.last_activity_year_month and    -- the current month is after the last month of activity&#xD;&#xA;             (pre_driver.next_renewal_month &lt; pre_driver.year_month_number or -- and the next renewal date is before the current month of activity&#xD;&#xA;              (pre_driver.next_renewal_month = pre_driver.year_month_number and &#xD;&#xA;              pre_driver.next_renewal_month &lt; pre_driver.last_activity_year_month and pre_driver.is_paid is null)) -- or the original is_paid value is null meaning no activity on the renewal month, as long as this is not the last month of activity&#xD;&#xA;             then '~MISC_DEACT~' &#xD;&#xA;        else null&#xD;&#xA;     end as incomplete_hist_misc_churn&#xD;&#xA;     from&#xD;&#xA;    (select -- pre_driver query         &#xD;&#xA;        stg.payer_id,&#xD;&#xA;        'abcmouse' || stg.account_domain as account_domain,&#xD;&#xA;        dt.year_month_number,&#xD;&#xA;        stg.subscription_group,&#xD;&#xA;        case -- V9 use retention metric codes&#xD;&#xA;           when (position('~CDEACT~' in churn_metric.billing_metric_group_name) > 0 or &#xD;&#xA;                 position('~PCDEACT~' in churn_metric.billing_metric_group_name) > 0) then '~CNL_DEACT~'&#xD;&#xA;           when position('~NOARNWDEACT~' in churn_metric.billing_metric_group_name) > 0 then '~NOARNW_DEACT~'&#xD;&#xA;           when (position('~RDDEACT~' in churn_metric.billing_metric_group_name) > 0 or &#xD;&#xA;                 position('~PRDDEACT~' in churn_metric.billing_metric_group_name) > 0) then '~RNWFAIL_DEACT~'&#xD;&#xA;           when (position('~TPDEACT~' in churn_metric.billing_metric_group_name) > 0 or &#xD;&#xA;                 position('~PTPDEACT~' in churn_metric.billing_metric_group_name) > 0) then '~TP_DEACT~'&#xD;&#xA;           when position('~RNWVOIDED~' in churn_metric.billing_metric_group_name) > 0 then '~RNWVOID_DEACT~'&#xD;&#xA;           when (rfnd_full.member_id is not null) or -- V9 add refunded churn type, full refund with no more access to site, V12 this sub query only handles 3000 activities&#xD;&#xA;                ((position('~RDEACT~' in churn_metric.billing_metric_group_name) > 0 or  -- V9 refund transactions could be missing &#xD;&#xA;                 position('~PRDEACT~' in churn_metric.billing_metric_group_name) > 0) and &#xD;&#xA;                 position('~FRFND~' in churn_metric.billing_metric_group_name) > 0) then '~RFND_DEACT~'  -- V9 changed from PRFND&#xD;&#xA;           when position('~MISCDEACT~' in churn_metric.billing_metric_group_name) > 0 or &#xD;&#xA;                position('~APPLYGIFT~' in churn_metric.billing_metric_group_name) > 0 or &#xD;&#xA;                position('~INSTALVOIDED~' in churn_metric.billing_metric_group_name) > 0 then '~MISC_DEACT~' -- V9 added misc churn&#xD;&#xA;           else null -- V9 changed to null, misc churn is handled above &#xD;&#xA;        end as retention_deactivation_metric_code,&#xD;&#xA;        case  -- V9 use retention metric codes&#xD;&#xA;           when add_metric.sub_metric_seq = 1 then  -- first activation&#xD;&#xA;              case -- special cases come first, more generic one after in the case statement&#xD;&#xA;               when add_metric.subscription_metric_group_name like '%~ACT~~UPG~%' then '~NPUPG_ACT~'&#xD;&#xA;               when add_metric.subscription_metric_group_name like '%~REACT~%' then '~RESUB_ACT~' &#xD;&#xA;               when (add_metric.subscription_metric_group_name is null and add_metric.billing_metric_group_name in ('~RNWOK~', '~RROK~' )) or&#xD;&#xA;                    (position('~ACT~' in add_metric.subscription_metric_group_name) = 0 and add_metric.billing_metric_group_name is null) or  &#xD;&#xA;                    (add_metric.subscription_metric_group_name like '%~ACT~~1030REACT~%') then '~MISC_ACT~'  -- V10 add activation on a 1030 'reactivation'&#xD;&#xA;               when add_metric.subscription_metric_group_name like '~SUB~~ACT~%' then  -- V10 pre-activation 'reactivation' removed from intmd_f_sub_billing_activity&#xD;&#xA;                  case &#xD;&#xA;                     when add_metric.billing_metric_group_name is null then '~NPDS_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~RNWOK~' then '~NPRNWOK_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~RROK~' then '~NPRROK_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~SROK~' then '~SROK_ACT~'   -- V10 few cases where SROK comes in with a SUB,ACT combo&#xD;&#xA;                  end&#xD;&#xA;               when add_metric.subscription_metric_group_name like '~ACT~%' then  -- V11 like ~ACT~% instead of = ~ACT~, there are other combo such as ~ACT~x~UPG~&#xD;&#xA;                  case &#xD;&#xA;                     when add_metric.billing_metric_group_name = '~INSTALOK~' then '~MISC_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~RNWOK~' then '~NPRNWOK_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~RROK~' then '~NPRROK_ACT~'&#xD;&#xA;                     when add_metric.billing_metric_group_name = '~SROK~' then '~SROK_ACT~'&#xD;&#xA;                  end&#xD;&#xA;            end&#xD;&#xA;            when add_metric.sub_metric_seq > 1 then  -- not the first activation&#xD;&#xA;              case &#xD;&#xA;                 when add_metric.subscription_metric_group_name like '%~REACT~%' then '~RESUB_ACT~' &#xD;&#xA;                 when add_metric.billing_metric_group_name = '~SROK~' then '~SROK_ACT~'&#xD;&#xA;                 when (add_metric.subscription_metric_group_name is null or add_metric.subscription_metric_group_name is not null) then '~MISC_ACT~' -- V15 blanket statement to include all remaining non-null sub or billing metric groups&#xD;&#xA;              end &#xD;&#xA;        end as retention_activation_metric_code,&#xD;&#xA;        stg_account_type.account_type,&#xD;&#xA;        stg.subscription_product_id,&#xD;&#xA;        stg_last_upg.product_id as upgrade_product_id,&#xD;&#xA;        stg.acquisition_channel,&#xD;&#xA;        stg.acquisition_source,&#xD;&#xA;        stg.acquisition_user_agent,&#xD;&#xA;        stg.account_created_date,&#xD;&#xA;        stg.subscription_datetime,&#xD;&#xA;        stg.activation_datetime,&#xD;&#xA;        stg_last_upg.activity_date as upgrade_datetime,&#xD;&#xA;        stg.subscription_year_month,&#xD;&#xA;        stg.activation_year_month,&#xD;&#xA;        stg_last_upg.activity_year_month as upgrade_year_month,&#xD;&#xA;        stg.last_activity_year_month,&#xD;&#xA;        case &#xD;&#xA;          when stg.activation_year_month is null or dt.year_month_number &lt; stg.activation_year_month then 0&#xD;&#xA;          else row_number() over(partition by stg.payer_id, stg.account_domain order by dt.year_month_number) - &#xD;&#xA;                     datediff(month, stg.subscription_datetime::date, stg.activation_datetime::date) &#xD;&#xA;        end as billing_period,&#xD;&#xA;        coalesce(stg_is_paid_month.num_payments_received_this_month, 0) as num_payments_received_this_month,&#xD;&#xA;        case when stg.subscription_year_month = dt.year_month_number then 1 else 0 end as is_subscription_year_month,&#xD;&#xA;        case when stg.activation_year_month = dt.year_month_number then 1 else 0 end as is_activation_year_month,&#xD;&#xA;        case when stg_last_upg.activity_year_month = dt.year_month_number then 1 else 0 end as is_upgrade_year_month,&#xD;&#xA;        case when stg.last_activity_year_month = dt.year_month_number then 1 else 0 end as is_last_activity_year_month,&#xD;&#xA;        case -- V9 switch over to taking the last is_paid value only&#xD;&#xA;           when stg_last_is_paid.is_paid is null then&#xD;&#xA;              last_value(stg_last_is_paid.is_paid) ignore nulls over (partition by stg.payer_id, stg.account_domain order by dt.year_month_number /*rows unbounded preceding*/)      &#xD;&#xA;             --windows.last_paid--V18 because snowflake does not support ignore nulls window funsctions, I wrote them as a left joined query, 'windows'&#xD;&#xA;           /*after further review, it was decided this is incorrect handling&#xD;&#xA;&#x9;&#x9;   --V16 adding check for failed renewals in trial that are followed by succeed in next month&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;when trial_decline.is_in_active_trial =1 and trial_decline.is_renewal_decline =1 and stg.activation_activity_id in (2020, 2070) and stg.activation_year_month = dt.year_month_number +1&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;then 1 --they declined all through this month and the payment went through next month, but counts here. normally, this is carried by last_value above, but not when its the initial activation.&#xD;&#xA;&#x9;&#x9;&#x9; */else stg_last_is_paid.is_paid&#xD;&#xA;        end as tmp_is_paid_this_month,  -- V9 temporary paid flag&#xD;&#xA;        stg_last_is_paid.is_paid, -- V10 added the uncorrected is_paid flag, needed for the final correction for incomplete histories&#xD;&#xA;        case -- V9 keep tabs on the next renewal month to catch incomplete account histories &#xD;&#xA;           when stg_last_is_paid.next_renewal_month is null then &#xD;&#xA;              last_value(stg_last_is_paid.next_renewal_month) ignore nulls over (partition by stg.payer_id, stg.account_domain order by dt.year_month_number /*rows unbounded preceding*/)&#xD;&#xA;              --windows.last_renewal_month--V18 because snowflake does not support ignore nulls window funsctions, I wrote them as a left joined query, 'windows'&#xD;&#xA;           else stg_last_is_paid.next_renewal_month&#xD;&#xA;        end as next_renewal_month&#xD;&#xA;      from     &#xD;&#xA;        (select -- get bulk of data such as subscription group, first sub and act dates, acquisition source and channel,...&#xD;&#xA;             payer_id, &#xD;&#xA;             account_domain, &#xD;&#xA;             max(case when subscription_metric_group_name like '%~SUB~%' then subscription_group else null end) as subscription_group,&#xD;&#xA;             max(case when subscription_metric_group_name like '%~SUB~%' then product_id else null end) as subscription_product_id,&#xD;&#xA;             min(case when subscription_metric_group_name like '%~SUB~%' then activity_year_month else null end) as subscription_year_month,&#xD;&#xA;             min(case when subscription_metric_group_name like '%~ACT~%' then activity_year_month else null end) as activation_year_month,&#xD;&#xA;             min(case when subscription_metric_group_name like '%~SUB~%' then activity_date else null end) as subscription_datetime,&#xD;&#xA;             min(case when subscription_metric_group_name like '%~ACT~%' then activity_date else null end) as activation_datetime,&#xD;&#xA;&#x9;&#x9;&#x9; min(case when subscription_metric_group_name like '%~ACT~%' then activity_id else null end) as activation_activity_id,--V16 added for check of failed renewals in free trial&#xD;&#xA;             max(account_created_date) as account_created_date,&#xD;&#xA;             max(acquisition_channel) as acquisition_channel,&#xD;&#xA;             max(acquisition_source) as acquisition_source,&#xD;&#xA;             max(acquisition_user_agent) as acquisition_user_agent,&#xD;&#xA;             min(activity_year_month) as first_activity_year_month,&#xD;&#xA;             max(activity_year_month) as last_activity_year_month,&#xD;&#xA;             max(activity_date) as last_activity_date -- V14 added to compare with orphaned refund day &#xD;&#xA;        from &#xD;&#xA;             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;        where&#xD;&#xA;             is_deleted = 0 and&#xD;&#xA;             is_unknown_account = 0 and&#xD;&#xA;             (subscription_group is not null or&#xD;&#xA;              subscription_metric_group_name is not null or&#xD;&#xA;              billing_metric_group_name is not null)&#xD;&#xA;        group by&#xD;&#xA;             payer_id, account_domain&#xD;&#xA;        )stg&#xD;&#xA;        left outer join&#xD;&#xA;        (select * from&#xD;&#xA;                (select -- get last recorded account type for payer_id/domain&#xD;&#xA;                     payer_id, account_domain, account_type,&#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) as rn&#xD;&#xA;                 from&#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                where&#xD;&#xA;                     account_type is not null&#xD;&#xA;                )where rn = 1&#xD;&#xA;       )stg_account_type&#xD;&#xA;       on&#xD;&#xA;          stg_account_type.payer_id = stg.payer_id and &#xD;&#xA;          stg_account_type.account_domain = stg.account_domain&#xD;&#xA;       left outer join&#xD;&#xA;        (select * from&#xD;&#xA;                (select -- get last upgrade product for payer_id/domain&#xD;&#xA;                     payer_id, account_domain, product_id, activity_year_month, activity_date,&#xD;&#xA;                     row_number() over (partition by payer_id, account_domain order by activity_date desc, account_hist_id desc) as rn&#xD;&#xA;                 from&#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                where&#xD;&#xA;                     subscription_metric_group_name like '%~UPG~%' &#xD;&#xA;                )where rn = 1&#xD;&#xA;       )stg_last_upg&#xD;&#xA;       on&#xD;&#xA;          stg_last_upg.payer_id = stg.payer_id and &#xD;&#xA;          stg_last_upg.account_domain = stg.account_domain  &#xD;&#xA;       cross join&#xD;&#xA;        (select year_month_number from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw where year_month_number &lt;=(select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)) dt&#xD;&#xA;       left outer join&#xD;&#xA;        (select -- sum up whether a payment was made during the month and how many were made&#xD;&#xA;                payer_id, account_domain, activity_year_month, &#xD;&#xA;                case when sum_is_paid > 0 then 1 else 0 end as is_paid_this_month,&#xD;&#xA;                case when num_payments_received_this_month > 0 then 1 else 0 end as is_paying_event_this_month,&#xD;&#xA;                num_payments_received_this_month&#xD;&#xA;         from&#xD;&#xA;                (select &#xD;&#xA;                     payer_id, account_domain, &#xD;&#xA;                     activity_year_month,&#xD;&#xA;                     sum(is_paid) as sum_is_paid,&#xD;&#xA;                     sum(is_paying_event) as num_payments_received_this_month&#xD;&#xA;                 from&#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity  &#xD;&#xA;                where&#xD;&#xA;                     is_deleted = 0 and&#xD;&#xA;                     is_unknown_account = 0 &#xD;&#xA;                     -- V10 remove metric filter, need all entries to get proper results&#xD;&#xA;                 group by&#xD;&#xA;                     payer_id, account_domain, activity_year_month&#xD;&#xA;                )&#xD;&#xA;       )stg_is_paid_month&#xD;&#xA;       on&#xD;&#xA;          stg_is_paid_month.payer_id = stg.payer_id and &#xD;&#xA;          stg_is_paid_month.account_domain = stg.account_domain and&#xD;&#xA;          stg_is_paid_month.activity_year_month = dt.year_month_number&#xD;&#xA;       left outer join&#xD;&#xA;        (select * from&#xD;&#xA;                (select -- get last is_paid value and expected renewal date at the end of each month&#xD;&#xA;                     payer_id, account_domain,&#xD;&#xA;                     is_paid, &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9; &#xD;&#xA;                     activity_id,&#xD;&#xA;                     activity_year_month,&#xD;&#xA;                     date_part('year', next_renewal_or_termination_forward_day) * 100 + date_part('month', next_renewal_or_termination_forward_day) as next_renewal_month,&#xD;&#xA;                     billing_metric_group_name,&#xD;&#xA;                     activity_day,&#xD;&#xA;                     row_number() over (partition by payer_id, account_domain, activity_year_month order by activity_date desc, account_hist_id desc) as rn  -- V8 sometimes a failed refund appears on the same activity date, with a higher account_hist_id&#xD;&#xA;                from&#xD;&#xA;                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                where&#xD;&#xA;                     is_deleted = 0 and&#xD;&#xA;                     is_unknown_account = 0 &#xD;&#xA;                     -- V10 remove metric filter, need all entries to get proper results                &#xD;&#xA;                )where rn = 1&#xD;&#xA;       )stg_last_is_paid&#xD;&#xA;       on&#xD;&#xA;          stg_last_is_paid.payer_id = stg.payer_id and &#xD;&#xA;          stg_last_is_paid.account_domain = stg.account_domain and&#xD;&#xA;          stg_last_is_paid.activity_year_month = dt.year_month_number&#xD;&#xA;&#x9;&#x9;  &#xD;&#xA;&#x9;  left outer join --V16  adding in is_in_active_trial, is_renewal_decline for the case when first renewal fails and the month changes over before they succeed&#xD;&#xA;&#x9;  (select &#xD;&#xA;&#x9;&#x9;&#x9;payer_id, &#xD;&#xA;&#x9;&#x9;&#x9;account_domain,&#xD;&#xA;&#x9;&#x9;&#x9;is_in_active_trial,&#xD;&#xA;&#x9;&#x9;&#x9;is_renewal_decline,&#xD;&#xA;&#x9;&#x9;&#x9;activity_year_month&#xD;&#xA;&#x9;&#x9;from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity where is_in_active_trial=1 and is_renewal_decline=1&#xD;&#xA;&#x9;  ) trial_decline&#xD;&#xA;&#x9;  on&#xD;&#xA;&#x9;&#x9;  trial_decline.payer_id = stg.payer_id and &#xD;&#xA;          trial_decline.account_domain = stg.account_domain and&#xD;&#xA;          trial_decline.activity_year_month = dt.year_month_number&#xD;&#xA;&#x9;&#x9;  &#xD;&#xA;      left outer join  -- V9 fetch sub and billing metrics in 2 separate passes, first aggregating all metrics found within a single month, then computing the total number of metrics rows and the position of each metric over the lifetime of the account&#xD;&#xA;      (select -- subscription metric per month with billing metric if on the same line (both are needed to compute add type)&#xD;&#xA;           payer_id,&#xD;&#xA;           account_domain,&#xD;&#xA;           activity_year_month,&#xD;&#xA;           -- V9 nullifies blank sub metric groups, must be done after the listagg&#xD;&#xA;           nullif(subscription_metric_group_name, '') as subscription_metric_group_name,&#xD;&#xA;           nullif(billing_metric_group_name, '') as billing_metric_group_name,&#xD;&#xA;           sub_metric_total,&#xD;&#xA;           sub_metric_seq&#xD;&#xA;        from  --4,850,280&#xD;&#xA;         (select  -- metric sub-query&#xD;&#xA;               metric.payer_id,&#xD;&#xA;               metric.account_domain,&#xD;&#xA;               metric.activity_year_month,    &#xD;&#xA;               -- V9 gather same month activity codes in one string, x separated&#xD;&#xA;               listagg(metric.subscription_metric_group_name, 'x') within group (order by metric.activity_date, metric.account_hist_id) over (partition by payer_id, account_domain, activity_year_month)  as subscription_metric_group_name,&#xD;&#xA;               metric.billing_metric_group_name,&#xD;&#xA;               count(1) over (partition by metric.payer_id, metric.account_domain) as sub_metric_total,&#xD;&#xA;               row_number() over (partition by metric.payer_id, metric.account_domain order by metric.activity_date, metric.account_hist_id) as sub_metric_seq,&#xD;&#xA;               row_number() over (partition by metric.payer_id, metric.account_domain, metric.activity_year_month order by metric.activity_date, metric.account_hist_id) as rn&#xD;&#xA;            from&#xD;&#xA;                (select * from&#xD;&#xA;                    (select&#xD;&#xA;                        payer_id, account_domain, account_hist_id, activity_day, activity_date, activity_year_month,&#xD;&#xA;                        -- V9 gather same day activity codes in one string, | separated&#xD;&#xA;                        listagg(subscription_metric_group_name, '|') within group (order by activity_date, account_hist_id) over (partition by payer_id, account_domain, activity_day)  as subscription_metric_group_name,&#xD;&#xA;                        billing_metric_group_name,&#xD;&#xA;                        row_number() over (partition by payer_id, account_domain, activity_day order by account_hist_id) as rn&#xD;&#xA;                     from&#xD;&#xA;                         (select  &#xD;&#xA;                             payer_id,&#xD;&#xA;                             account_domain,&#xD;&#xA;                             account_hist_id,&#xD;&#xA;                             activity_day,&#xD;&#xA;                             activity_date,&#xD;&#xA;                             activity_year_month,&#xD;&#xA;                             -- V9 make sure the components always appear in the same order (to avoid ~SUB~,~ACT~ and ~ACT~,~SUB~ for instance)&#xD;&#xA;                             case when position('~SUB~' in subscription_metric_group_name) > 0 then '~SUB~' else '' end ||&#xD;&#xA;                             case when position('~ACT~' in subscription_metric_group_name) > 0 then '~ACT~' else '' end ||&#xD;&#xA;                             case when position('~UPG~' in subscription_metric_group_name) > 0 then '~UPG~' else ''end  ||&#xD;&#xA;                             case &#xD;&#xA;                                when position('~REACT~' in subscription_metric_group_name) > 0 then &#xD;&#xA;                                   case &#xD;&#xA;                                      when activity_id = 1030 then '~1030REACT~'  -- 1030 activity id does not count as a resubscription, but as a misc. add&#xD;&#xA;                                      else '~REACT~'&#xD;&#xA;                                   end &#xD;&#xA;                                when subscription_metric_group_name not like '%~SUB~%' and subscription_metric_group_name not like '%~ACT~%' and &#xD;&#xA;                                     subscription_metric_group_name not like '%~UPG~%' and subscription_metric_group_name not like '%~REACT~%' then&#xD;&#xA;                                     subscription_metric_group_name&#xD;&#xA;                                else ''&#xD;&#xA;                             end as subscription_metric_group_name,&#xD;&#xA;                             billing_metric_group_name&#xD;&#xA;                          from&#xD;&#xA;                             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity&#xD;&#xA;                          where&#xD;&#xA;                             is_deleted = 0 and&#xD;&#xA;                             is_unknown_account = 0 and&#xD;&#xA;                             (subscription_metric_group_name is not null or billing_metric_group_name in ('~SROK~', '~RROK~', '~RNWOK~'))&#xD;&#xA;                         )&#xD;&#xA;                    )where rn = 1 -- one per day&#xD;&#xA;                )metric&#xD;&#xA;                where &#xD;&#xA;                  trim(subscription_metric_group_name) = '' or -- V11 subscription metric can either be empty&#xD;&#xA;                  regexp_replace(subscription_metric_group_name, '~SUB~|~ASMT~|||x') &lt;> ''  -- V11 or must contain something else than a combination of ~SUB~ and ~ASMT~&#xD;&#xA;         )&#xD;&#xA;         where &#xD;&#xA;            rn = 1 -- one per month&#xD;&#xA;       )add_metric&#xD;&#xA;       on &#xD;&#xA;          add_metric.payer_id = stg.payer_id and&#xD;&#xA;          add_metric.account_domain = stg.account_domain and&#xD;&#xA;          add_metric.activity_year_month = dt.year_month_number&#xD;&#xA;       left outer join&#xD;&#xA;       (select   -- billing metric per month for churn types&#xD;&#xA;          *&#xD;&#xA;        from&#xD;&#xA;        (select&#xD;&#xA;            metric.payer_id, metric.account_domain, metric.activity_year_month,&#xD;&#xA;            listagg(metric.billing_metric_group_name, 'x') within group (order by metric.activity_day) over (partition by metric.payer_id, metric.account_domain, metric.activity_day)  as billing_metric_group_name,&#xD;&#xA;            count(1) over (partition by metric.payer_id, metric.account_domain) as billing_metric_total,&#xD;&#xA;            row_number() over (partition by metric.payer_id, metric.account_domain order by metric.activity_day) as billing_metric_seq,&#xD;&#xA;            row_number() over (partition by metric.payer_id, metric.account_domain, metric.activity_year_month order by metric.activity_day desc) as rn&#xD;&#xA;         from&#xD;&#xA;         (select -- metric sub-query&#xD;&#xA;             payer_id, account_domain, activity_day, activity_year_month, replace(billing_metric_group_name, ',', '') as billing_metric_group_name&#xD;&#xA;          from&#xD;&#xA;             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity&#xD;&#xA;          where&#xD;&#xA;             is_deleted = 0 and&#xD;&#xA;             is_unknown_account = 0 and&#xD;&#xA;             billing_metric_group_name is not null and &#xD;&#xA;             (activity_id is null or activity_id not in (3010)) and -- V9 remove partial refunds, not used as a churn type&#xD;&#xA;             billing_metric_group_name not in ('~RNWFAIL~', '~RRFAIL~', '~SRFAIL~', '~OUCNL~') -- V9 remove billing metrics not used as a churn type&#xD;&#xA;          group by &#xD;&#xA;             1, 2, 3, 4, 5  --one distinct metric group per payer and day&#xD;&#xA;         )metric&#xD;&#xA;       )&#xD;&#xA;       where rn = 1  -- one row per month&#xD;&#xA;      )churn_metric&#xD;&#xA;      on&#xD;&#xA;         churn_metric.payer_id = stg.payer_id and &#xD;&#xA;         churn_metric.account_domain = stg.account_domain and&#xD;&#xA;         churn_metric.activity_year_month = dt.year_month_number&#xD;&#xA;      left outer join -- V9 join to the refund data&#xD;&#xA;      (select * from  -- rfnd_full&#xD;&#xA;         (select -- get last refund per payer/domain per year_month&#xD;&#xA;             member_id, account_domain, account_hist_activity_id, refund_year_month, is_orphaned_trx,&#xD;&#xA;             row_number() over (partition by member_id, account_domain, refund_year_month order by refund_sequence_num desc) as rn&#xD;&#xA;          from&#xD;&#xA;             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_refund_activity&#xD;&#xA;          where&#xD;&#xA;             is_deleted = 0 and&#xD;&#xA;             account_hist_activity_id = 3000  --V12 keep this sub-query for full refunds ('Refunded' churn type)&#xD;&#xA;          )where rn = 1&#xD;&#xA;       )rfnd_full&#xD;&#xA;       on&#xD;&#xA;          rfnd_full.member_id = stg.payer_id and &#xD;&#xA;          rfnd_full.account_domain = stg.account_domain and&#xD;&#xA;          rfnd_full.refund_year_month = dt.year_month_number&#xD;&#xA;       /*left outer join --V18 because snowflake does not support ignore nulls window funsctions, I wrote them as a left joined query, 'windows'&#xD;&#xA;       (--windows subquery   &#xD;&#xA;          select paid_window.payer_id, paid_window.account_domain, paid_window.year_month_number, paid_window.last_paid, renewal_window.last_renewal_month from&#xD;&#xA;                (--renewal window&#xD;&#xA;                select payer_id, account_domain, year_month_number, last_renewal_month from(&#xD;&#xA;                select src.payer_id, src.account_domain, src.year_month_number, next_renewal_window.next_renewal_month as last_renewal_month,  src.first_activity_year_month,&#xD;&#xA;                row_number() over (partition by src.payer_id, src.account_domain, src.year_month_number order by next_renewal_window.year_month_number desc) as rn&#xD;&#xA;                from &#xD;&#xA;                (select stg.payer_id, stg.account_domain, dt.year_month_number, stg_last_is_paid.next_renewal_month, stg.first_activity_year_month&#xD;&#xA;                &#xD;&#xA;                        from&#xD;&#xA;                        (select      payer_id, &#xD;&#xA;                                     account_domain &#xD;&#xA;                                     ,min(activity_year_month) as first_activity_year_month&#xD;&#xA;                                     from &#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 and&#xD;&#xA;                                     (subscription_group is not null or&#xD;&#xA;                                      subscription_metric_group_name is not null or&#xD;&#xA;                                      billing_metric_group_name is not null)&#xD;&#xA;                                group by&#xD;&#xA;                                     payer_id, account_domain&#xD;&#xA;                                )stg&#xD;&#xA;                                    cross join&#xD;&#xA;                                (select year_month_number from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw where year_month_number &lt;=(select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)) dt        &#xD;&#xA;                                       left outer join&#xD;&#xA;                                (select * from&#xD;&#xA;                                        (select -- get last is_paid value and expected renewal date at the end of each month&#xD;&#xA;                                             payer_id, account_domain, activity_year_month,&#xD;&#xA;                                             date_part('year', next_renewal_or_termination_forward_day) * 100 + date_part('month', next_renewal_or_termination_forward_day) as next_renewal_month,&#xD;&#xA;                                             row_number() over (partition by payer_id, account_domain, activity_year_month order by activity_date desc, account_hist_id desc) as rn  -- V8 sometimes a failed refund appears on the same activity date, with a higher account_hist_id&#xD;&#xA;                                        from&#xD;&#xA;                                             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                        where&#xD;&#xA;                                             is_deleted = 0 and&#xD;&#xA;                                             is_unknown_account = 0 &#xD;&#xA;                                             -- V10 remove metric filter, need all entries to get proper results                &#xD;&#xA;                                        )where rn = 1&#xD;&#xA;                               )stg_last_is_paid&#xD;&#xA;                               on&#xD;&#xA;                                  stg_last_is_paid.payer_id = stg.payer_id and &#xD;&#xA;                                  stg_last_is_paid.account_domain = stg.account_domain and&#xD;&#xA;                                  stg_last_is_paid.activity_year_month = dt.year_month_number&#xD;&#xA;                                  &#xD;&#xA;                ) src--for renewal window&#xD;&#xA;                left join&#xD;&#xA;                (&#xD;&#xA;                select stg.payer_id, stg.account_domain, dt.year_month_number, stg_last_is_paid.next_renewal_month&#xD;&#xA;                &#xD;&#xA;                        from&#xD;&#xA;                        (select -- get bulk of data such as subscription group, first sub and act dates, acquisition source and channel,...&#xD;&#xA;                                     payer_id, &#xD;&#xA;                                     account_domain &#xD;&#xA;                                     --,min(activity_year_month) as first_activity_year_month&#xD;&#xA;                                from &#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 and&#xD;&#xA;                                     (subscription_group is not null or&#xD;&#xA;                                      subscription_metric_group_name is not null or&#xD;&#xA;                                      billing_metric_group_name is not null)&#xD;&#xA;                                group by&#xD;&#xA;                                     payer_id, account_domain&#xD;&#xA;                                )stg&#xD;&#xA;                                    cross join&#xD;&#xA;                                (select year_month_number from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw where year_month_number &lt;=(select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)) dt        &#xD;&#xA;                                       left outer join&#xD;&#xA;                                (select * from&#xD;&#xA;                                        (select -- get last is_paid value and expected renewal date at the end of each month&#xD;&#xA;                                             payer_id, account_domain, activity_year_month,&#xD;&#xA;                                             date_part('year', next_renewal_or_termination_forward_day) * 100 + date_part('month', next_renewal_or_termination_forward_day) as next_renewal_month,&#xD;&#xA;                                             row_number() over (partition by payer_id, account_domain, activity_year_month order by activity_date desc, account_hist_id desc) as rn  -- V8 sometimes a failed refund appears on the same activity date, with a higher account_hist_id&#xD;&#xA;                                        from&#xD;&#xA;                                             &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                        where&#xD;&#xA;                                             is_deleted = 0 and&#xD;&#xA;                                             is_unknown_account = 0 &#xD;&#xA;                                             -- V10 remove metric filter, need all entries to get proper results                &#xD;&#xA;                                        )where rn = 1&#xD;&#xA;                               )stg_last_is_paid--for renewal window&#xD;&#xA;                               on&#xD;&#xA;                                  stg_last_is_paid.payer_id = stg.payer_id and &#xD;&#xA;                                  stg_last_is_paid.account_domain = stg.account_domain and&#xD;&#xA;                                  stg_last_is_paid.activity_year_month = dt.year_month_number&#xD;&#xA;                                  where stg_last_is_paid.next_renewal_month is not null&#xD;&#xA;                )&#xD;&#xA;                next_renewal_window&#xD;&#xA;                on next_renewal_window.payer_id = src.payer_id&#xD;&#xA;                and next_renewal_window.account_domain = src.account_domain&#xD;&#xA;                and next_renewal_window.year_month_number &lt;src.year_month_number&#xD;&#xA;                order by src.payer_id, src.account_domain, src.year_month_number&#xD;&#xA;                )&#xD;&#xA;                where rn=1&#xD;&#xA;                and year_month_number between first_activity_year_month and (select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)&#xD;&#xA;                ) renewal_window left join(--paid_window&#xD;&#xA;                select payer_id, account_domain, year_month_number, last_paid from(&#xD;&#xA;                select src.payer_id, src.account_domain, src.year_month_number, is_paid_window.is_paid as last_paid,  src.first_activity_year_month,&#xD;&#xA;                row_number() over (partition by src.payer_id, src.account_domain, src.year_month_number order by is_paid_window.year_month_number desc) as rn&#xD;&#xA;                from&#xD;&#xA;                (--src for paid window&#xD;&#xA;                select stg.payer_id, stg.account_domain, dt.year_month_number, stg_last_is_paid.is_paid, stg.first_activity_year_month&#xD;&#xA;                &#xD;&#xA;                        from&#xD;&#xA;                        (select -- get bulk of data such as subscription group, first sub and act dates, acquisition source and channel,...&#xD;&#xA;                                     payer_id, &#xD;&#xA;                                     account_domain &#xD;&#xA;                                     ,min(activity_year_month) as first_activity_year_month&#xD;&#xA;                                from &#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 and&#xD;&#xA;                                     (subscription_group is not null or&#xD;&#xA;                                      subscription_metric_group_name is not null or&#xD;&#xA;                                      billing_metric_group_name is not null)&#xD;&#xA;                                group by&#xD;&#xA;                                     payer_id, account_domain&#xD;&#xA;                                )stg&#xD;&#xA;                                    cross join&#xD;&#xA;                                (select year_month_number from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw where year_month_number &lt;=(select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)) dt        &#xD;&#xA;                                       left outer join&#xD;&#xA;                                       (select * from&#xD;&#xA;                                (select -- get last is_paid value and expected renewal date at the end of each month&#xD;&#xA;                                     payer_id, account_domain,&#xD;&#xA;                                     is_paid,&#xD;&#xA;                                     activity_year_month,&#xD;&#xA;                                     row_number() over (partition by payer_id, account_domain, activity_year_month order by activity_date desc, account_hist_id desc) as rn  -- V8 sometimes a failed refund appears on the same activity date, with a higher account_hist_id&#xD;&#xA;                                from&#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 &#xD;&#xA;                                     -- V10 remove metric filter, need all entries to get proper results     &#xD;&#xA;                                )where rn = 1&#xD;&#xA;                       )stg_last_is_paid&#xD;&#xA;                       on&#xD;&#xA;                          stg_last_is_paid.payer_id = stg.payer_id and &#xD;&#xA;                          stg_last_is_paid.account_domain = stg.account_domain and&#xD;&#xA;                          stg_last_is_paid.activity_year_month = dt.year_month_number&#xD;&#xA;                ) src&#xD;&#xA;                left join&#xD;&#xA;                (--is paid for paid window&#xD;&#xA;                select stg.payer_id, stg.account_domain, dt.year_month_number, stg_last_is_paid.is_paid&#xD;&#xA;                &#xD;&#xA;                        from&#xD;&#xA;                        (select -- get bulk of data such as subscription group, first sub and act dates, acquisition source and channel,...&#xD;&#xA;                                     payer_id, &#xD;&#xA;                                     account_domain &#xD;&#xA;                                     --,min(activity_year_month) as first_activity_year_month&#xD;&#xA;                                from &#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 and&#xD;&#xA;                                     (subscription_group is not null or&#xD;&#xA;                                      subscription_metric_group_name is not null or&#xD;&#xA;                                      billing_metric_group_name is not null)&#xD;&#xA;                                group by&#xD;&#xA;                                     payer_id, account_domain&#xD;&#xA;                                )stg&#xD;&#xA;                                    cross join&#xD;&#xA;                                (select year_month_number from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw where year_month_number &lt;=(select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity)) dt        &#xD;&#xA;                                       left outer join&#xD;&#xA;                                       (select * from&#xD;&#xA;                                (select -- get last is_paid value and expected renewal date at the end of each month&#xD;&#xA;                                     payer_id, account_domain,&#xD;&#xA;                                     is_paid,&#xD;&#xA;                                     activity_year_month,&#xD;&#xA;                                     row_number() over (partition by payer_id, account_domain, activity_year_month order by activity_date desc, account_hist_id desc) as rn  -- V8 sometimes a failed refund appears on the same activity date, with a higher account_hist_id&#xD;&#xA;                                from&#xD;&#xA;                                     &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity   &#xD;&#xA;                                where&#xD;&#xA;                                     is_deleted = 0 and&#xD;&#xA;                                     is_unknown_account = 0 &#xD;&#xA;                                     -- V10 remove metric filter, need all entries to get proper results                &#xD;&#xA;                                )where rn = 1&#xD;&#xA;                               )stg_last_is_paid&#xD;&#xA;                               on&#xD;&#xA;                                  stg_last_is_paid.payer_id = stg.payer_id and &#xD;&#xA;                                  stg_last_is_paid.account_domain = stg.account_domain and&#xD;&#xA;                                  stg_last_is_paid.activity_year_month = dt.year_month_number&#xD;&#xA;                                  where stg_last_is_paid.is_paid is not null&#xD;&#xA;                ) is_paid_window&#xD;&#xA;                on is_paid_window.payer_id = src.payer_id&#xD;&#xA;                and is_paid_window.account_domain = src.account_domain&#xD;&#xA;                and is_paid_window.year_month_number &lt;src.year_month_number&#xD;&#xA;                order by src.payer_id, src.account_domain, src.year_month_number&#xD;&#xA;                )&#xD;&#xA;                where rn=1&#xD;&#xA;                and year_month_number between first_activity_year_month and (select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity) &#xD;&#xA;                ) paid_window&#xD;&#xA;                on paid_window.payer_id = renewal_window.payer_id&#xD;&#xA;                and paid_window.account_domain = renewal_window.account_domain&#xD;&#xA;                and paid_window.year_month_number = renewal_window.year_month_number&#xD;&#xA;                --where paid_window.rn = 1 and renewal_window.rn =1&#xD;&#xA;                       ) windows   &#xD;&#xA;       on&#xD;&#xA;       stg.payer_id = windows.payer_id and&#xD;&#xA;       stg.account_domain = windows.account_domain and&#xD;&#xA;       dt.year_month_number = windows.year_month_number*/&#xD;&#xA;       where&#xD;&#xA;        dt.year_month_number between stg.first_activity_year_month and (select max(activity_year_month) from &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_sub_billing_activity) &#xD;&#xA;      )pre_driver&#xD;&#xA;  )driver&#xD;&#xA;where &#xD;&#xA;   subscription_group is not null&#xD;&#xA;)pre_fact&#xD;&#xA;)fact&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_family d_f                       ON d_f.parentid = fact.payer_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_domain d_d                       ON d_d.domain_name = fact.account_domain&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_monthly_date_vw m_vw             ON m_vw.year_month_number = fact.year_month_number&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_subscription_group d_sg          ON d_sg.subscription_group = fact.subscription_group&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_metric d_m_churn                 ON (d_m_churn.metric_code = replace(fact.retention_deactivation_metric_code, '_','') -- V9 added link to metric dim&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;and d_m_churn.metric_category ='Retention Deactivation')&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_metric d_m_add                   ON (d_m_add.metric_code = replace(fact.retention_activation_metric_code,'_','')     -- V9 added link to metric dim&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;and d_m_add.metric_category = 'Retention Activation')&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_type d_at                ON d_at.account_type_id = fact.account_type&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p_sub                  ON d_p_sub.product_id = fact.subscription_product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p_upg                  ON d_p_upg.product_id = fact.upgrade_product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_channel d_ac         ON d_ac.acquisition_channel_name = fact.acquisition_channel&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_source d_as          ON d_as.acquisition_source_name = fact.acquisition_source&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_ac                     ON d_dt_ac.fulldate = fact.account_created_date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_sub                    ON d_dt_sub.fulldate = fact.subscription_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_act                    ON d_dt_act.fulldate = fact.activation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_upg                    ON d_dt_upg.fulldate = fact.upgrade_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_cohort d_cs                      ON d_cs.cohort_year_month_number = fact.subscription_year_month&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_cohort d_ca                      ON d_ca.cohort_year_month_number = fact.activation_year_month&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select max(device_hierarchy_key) as device_hierarchy_key, custom_user_agent from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_device_hierarchy group by custom_user_agent) d_dh        &#xD;&#xA;ON &#xD;&#xA;    d_dh.custom_user_agent = fact.acquisition_user_agent&#xD;&#xA;WHERE -- V8 remove blank rows  before: 111,113,915; after: 53,995,230, &#xD;&#xA;   fact.is_subscription_year_month + fact.is_activation_year_month + fact.is_paid_this_month + fact.is_paid_to_retain + fact.is_paid_retained > 0&#xD;&#xA;ORDER BY &#xD;&#xA;   payer_id, &#xD;&#xA;   domain_key, &#xD;&#xA;   calendar_month_date_key, &#xD;&#xA;   subscription_group_key&#xD;&#xA;;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="insert&lt;br>f_subscriber_retention"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_8"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="672">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_9"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;DELETE FROM &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention_frozen &#xD;&#xA;WHERE year_month_number = (select max(year_month_number) from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention_frozen) -- V10 wipe out data from current month (not yet frozen)&#xD;&#xA;;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="delete&lt;br>f_subscriber_retention_frozen"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_9"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="416" posY="672">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_10"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;INSERT INTO &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention_frozen &#xD;&#xA;SELECT * FROM &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention&#xD;&#xA;WHERE year_month_number > (select max(year_month_number) from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_retention_frozen) -- V10 add latest data from retention, if the year_month_number is higher than the last frozen month &#xD;&#xA;;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="insert&lt;br>f_subscriber_retention_frozen"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_10"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="800">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_11"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;DELETE FROM &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_refund  &#xD;&#xA;USING &#xD;&#xA;(select -- look for rows inserted in the intermediate table after the last run of this fact table&#xD;&#xA;    'abcmouse' || f.account_domain as del_account_domain, f.trx_hist_id as del_trx_hist_id, f.created_ts&#xD;&#xA;from &#xD;&#xA;    &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_refund_activity f &#xD;&#xA;where -- this will also delete the activities changed to is_deleted in the last run of the intermediate table &#xD;&#xA;    f.created_ts > (select coalesce(max(created_ts), '1970-01-01'::timestamp) from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_refund) &#xD;&#xA;)del&#xD;&#xA;WHERE&#xD;&#xA;   del.del_account_domain = account_domain and&#xD;&#xA;   del.del_trx_hist_id = trx_hist_id&#xD;&#xA;;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="delete&lt;br>f_subscriber_refund"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_11"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="416" posY="800">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_12"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;insert into  &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_refund&#xD;&#xA;&#xD;&#xA;select&#xD;&#xA;   coalesce(d_f.family_key, 0) as family_key,&#xD;&#xA;   coalesce(d_d.domain_key, 0) as domain_key,&#xD;&#xA;   coalesce(d_dt_rfnd.date_key, 0) as refund_date_key,&#xD;&#xA;   coalesce(d_dt_ac.date_key, 0) as account_created_date_key,&#xD;&#xA;   coalesce(d_dt_sub.date_key, 0) as subscription_date_key,    &#xD;&#xA;   coalesce(d_dt_act.date_key, 0) as activation_date_key,&#xD;&#xA;   coalesce(d_at.account_type_key, 0) as account_type_key,&#xD;&#xA;   coalesce(d_p.product_key, 0) as product_key,&#xD;&#xA;   coalesce(d_sg.subscription_group_key, 0) as subscription_group_key,   &#xD;&#xA;   coalesce(d_ac.acquisition_channel_key, 0) as acquisition_channel_key,&#xD;&#xA;   coalesce(d_as.acquisition_source_key, 0) as acquisition_source_key,&#xD;&#xA;   coalesce(d_dh.device_hierarchy_key, 0) as acquisition_device_hierarchy_key,&#xD;&#xA;   coalesce(d_ti.transaction_info_key, 0) as transaction_info_key,&#xD;&#xA;   coalesce(d_cc.transaction_cc_type_key, 0) as transaction_cc_type_key,&#xD;&#xA;   coalesce(d_aa.account_activity_key, 0) as account_activity_key,&#xD;&#xA;   coalesce(brg_b.billing_metric_group_key, 0) as billing_metric_group_key,&#xD;&#xA;    &#xD;&#xA;   stg.member_id,&#xD;&#xA;   stg.account_domain,&#xD;&#xA;   stg.refund_datetime, &#xD;&#xA;   stg.account_created_date,&#xD;&#xA;   stg.subscription_datetime,&#xD;&#xA;   stg.activation_datetime,&#xD;&#xA;   stg.transaction_settled_datetime,&#xD;&#xA;   stg.trx_hist_id,&#xD;&#xA;   stg.account_type,&#xD;&#xA;   stg.product_id,&#xD;&#xA;   stg.subscription_group,&#xD;&#xA;   stg.acquisition_channel,&#xD;&#xA;   stg.acquisition_source,&#xD;&#xA;   stg.acquisition_user_agent,&#xD;&#xA;   stg.refund_year_month,&#xD;&#xA;   stg.subscription_year_month,&#xD;&#xA;   stg.activation_year_month,               &#xD;&#xA;   stg.trx_reason,      &#xD;&#xA;   stg.trx_payment_type,   &#xD;&#xA;   stg.trx_cc_type, &#xD;&#xA;   stg.account_hist_id, &#xD;&#xA;   stg.account_hist_activity_datetime,&#xD;&#xA;   stg.account_hist_activity_id,&#xD;&#xA;   stg.account_hist_activity_code,&#xD;&#xA;   stg.account_hist_activity_price, &#xD;&#xA;   to_boolean(stg.account_hist_is_unknown_account),&#xD;&#xA;   stg.billing_metric_group_name,&#xD;&#xA;&#xD;&#xA;   to_boolean(stg.is_orphaned_member),&#xD;&#xA;   to_boolean(stg.is_orphaned_trx),&#xD;&#xA;   to_boolean(stg.is_settled_trx),&#xD;&#xA; &#xD;&#xA;   stg.refund_amount,&#xD;&#xA;   stg.refund_sequence_num,&#xD;&#xA;   &#xD;&#xA;   to_timestamp_ntz(CURRENT_TIMESTAMP()) as createdt_ts,&#xD;&#xA;   '&quot;+jobName+&quot;' as created_by,&#xD;&#xA;   to_timestamp_ntz(CURRENT_TIMESTAMP()) as last_updated_ts,&#xD;&#xA;   '&quot;+jobName+&quot;' as last_updated_by&#xD;&#xA;from&#xD;&#xA;  (select&#xD;&#xA;     i.member_id,&#xD;&#xA;     'abcmouse' || i.account_domain as account_domain,&#xD;&#xA;     i.refund_date as refund_datetime,&#xD;&#xA;     i.account_created_date,&#xD;&#xA;     i.subscription_date as subscription_datetime,&#xD;&#xA;     i.activation_date as activation_datetime,&#xD;&#xA;     i.transaction_settled_date as transaction_settled_datetime,&#xD;&#xA;     i.trx_hist_id,&#xD;&#xA;     i.account_type,&#xD;&#xA;     i.product_id,&#xD;&#xA;     i.subscription_group,&#xD;&#xA;     i.acquisition_channel,&#xD;&#xA;     i.acquisition_source,&#xD;&#xA;     i.acquisition_user_agent,&#xD;&#xA;     i.refund_year_month,&#xD;&#xA;     i.subscription_year_month, &#xD;&#xA;     i.activation_year_month, &#xD;&#xA;     i.trx_reason,&#xD;&#xA;     i.trx_processor,&#xD;&#xA;     i.trx_updater,&#xD;&#xA;     i.trx_payment_type,&#xD;&#xA;     i.trx_cc_type,&#xD;&#xA;     i.account_hist_id,&#xD;&#xA;     i.account_hist_activity_date as account_hist_activity_datetime,&#xD;&#xA;     i.account_hist_activity_id,&#xD;&#xA;     i.account_hist_activity_code,&#xD;&#xA;     i.account_hist_activity_price,&#xD;&#xA;     i.account_hist_is_unknown_account,&#xD;&#xA;     i.billing_metric_group_name,        &#xD;&#xA;     i.is_orphaned_member,  -- 341,978 non-orphaned members, 40 orphaned members&#xD;&#xA;     i.is_orphaned_trx,  -- 299,744 orphanded trx, 42,274 non-orphaned trx&#xD;&#xA;     i.is_settled_trx,  &#xD;&#xA;     i.refund_amount,&#xD;&#xA;     i.refund_sequence_num&#xD;&#xA;  from&#xD;&#xA;      &quot;+globalMap.get(&quot;stg&quot;)+&quot;.intmd_f_refund_activity i&#xD;&#xA;   where&#xD;&#xA;      i.created_ts > (select coalesce(max(created_ts), '1970-01-01'::timestamp) from &quot;+globalMap.get(&quot;core&quot;)+&quot;.f_subscriber_refund) and  &#xD;&#xA;      i.is_deleted = 0 &#xD;&#xA;)stg&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_family d_f                       ON d_f.parentid = stg.member_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_domain d_d                       ON d_d.domain_name = stg.account_domain&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_rfnd                   ON d_dt_rfnd.fulldate = stg.refund_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_ac                     ON d_dt_ac.fulldate = stg.account_created_date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_sub                    ON d_dt_sub.fulldate = stg.subscription_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_date d_dt_act                    ON d_dt_act.fulldate = stg.activation_datetime::date&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_type d_at                ON d_at.account_type_id = stg.account_type&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_product d_p                      ON d_p.product_id = stg.product_id&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_subscription_group d_sg          ON d_sg.subscription_group = stg.subscription_group&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_channel d_ac         ON d_ac.acquisition_channel_name = stg.acquisition_channel&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_acquisition_source d_as          ON d_as.acquisition_source_name = stg.acquisition_source&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_transaction_cc_type d_cc         ON d_cc.trx_cc_type = stg.trx_cc_type&#xD;&#xA;LEFT OUTER JOIN &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_account_activity d_aa            ON d_aa.account_activity_id = stg.account_hist_activity_id&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_transaction_info d_ti            &#xD;&#xA;ON &#xD;&#xA;    d_ti.trx_reason = stg.trx_reason and&#xD;&#xA;    d_ti.trx_processor = stg.trx_processor and&#xD;&#xA;    d_ti.trx_updater = stg.trx_updater and&#xD;&#xA;    d_ti.trx_payment_type = stg.trx_payment_type&#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select max(device_hierarchy_key) as device_hierarchy_key, user_agent from &quot;+globalMap.get(&quot;core&quot;)+&quot;.d_device_hierarchy_new group by user_agent) d_dh        &#xD;&#xA;ON &#xD;&#xA;    d_dh.user_agent = stg.acquisition_user_agent   &#xD;&#xA;LEFT OUTER JOIN &#xD;&#xA;    (select distinct billing_metric_group_key, billing_metric_group_name from &quot;+globalMap.get(&quot;core&quot;)+&quot;.brg_billing_metric_group) brg_b       &#xD;&#xA;ON &#xD;&#xA;    brg_b.billing_metric_group_name = stg.billing_metric_group_name&#xD;&#xA;ORDER BY&#xD;&#xA;    member_id, &#xD;&#xA;    domain_key, &#xD;&#xA;    refund_date_key, &#xD;&#xA;    refund_sequence_num, &#xD;&#xA;    subscription_group_key, &#xD;&#xA;    product_key&#xD;&#xA;;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="insert &lt;br>f_subscriber_refund"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_12"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCRow" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="256" posY="928">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_13"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="CHECK" name="USE_EXISTING_CONNECTION" value="true"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="URL" value="&quot;jdbc:&quot;"/>
    <elementParameter field="TABLE" name="DRIVER_JAR"/>
    <elementParameter field="TEXT" name="DRIVER_CLASS" value="&quot;&quot;"/>
    <elementParameter field="TEXT" name="USER" value="&quot;&quot;"/>
    <elementParameter field="PASSWORD" name="PASS" value="0RMsyjmybrE="/>
    <elementParameter field="DBTABLE" name="TABLE" value="&quot;&quot;"/>
    <elementParameter field="QUERYSTORE_TYPE" name="QUERYSTORE" value="&quot;&quot;"/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:REPOSITORY_QUERYSTORE_TYPE" value=""/>
    <elementParameter field="TECHNICAL" name="QUERYSTORE:QUERYSTORE_TYPE" value="BUILT_IN"/>
    <elementParameter field="MEMO_SQL" name="QUERY" value="&quot;&#xD;&#xA;UPDATE &quot;+globalMap.get(&quot;meta&quot;)+&quot;.etl_job_log SET&#xD;&#xA;  job_status = 'DONE',&#xD;&#xA;  end_time = to_timestamp_ntz(CURRENT_TIMESTAMP()),&#xD;&#xA;  last_updated_ts = to_timestamp_ntz(CURRENT_TIMESTAMP()),&#xD;&#xA;  last_updated_by = '&quot;+jobName+&quot;'&#xD;&#xA;--from &quot;+globalMap.get(&quot;meta&quot;)+&quot;.etl_job_log --duplicate alias&#xD;&#xA;WHERE run_id = (select &#xD;&#xA;                  max(run_id) &#xD;&#xA;               from &#xD;&#xA;                  &quot;+globalMap.get(&quot;meta&quot;)+&quot;.etl_job_log &#xD;&#xA;               where &#xD;&#xA;                  job_Name = '&quot;+jobName+&quot;'&#xD;&#xA;               )&#xD;&#xA;               and job_Name = '&quot;+jobName+&quot;'&#xD;&#xA;;&#xD;&#xA;&quot;"/>
    <elementParameter field="CHECK" name="DIE_ON_ERROR" value="true"/>
    <elementParameter field="LABEL" name="NOTE" value="This option only applies when deploying and running in the Talend Runtime"/>
    <elementParameter field="CHECK" name="SPECIFY_DATASOURCE_ALIAS" value="false"/>
    <elementParameter field="TEXT" name="DATASOURCE_ALIAS" value="&quot;&quot;"/>
    <elementParameter field="CHECK" name="PROPAGATE_RECORD_SET" value="false"/>
    <elementParameter field="COLUMN_LIST" name="RECORD_SET_COLUMN" value=""/>
    <elementParameter field="CHECK" name="USE_PREPAREDSTATEMENT" value="false"/>
    <elementParameter field="TABLE" name="SET_PREPAREDSTATEMENT_PARAMETERS"/>
    <elementParameter field="ENCODING_TYPE" name="ENCODING" value="&quot;ISO-8859-15&quot;"/>
    <elementParameter field="TECHNICAL" name="ENCODING:ENCODING_TYPE" value="ISO-8859-15"/>
    <elementParameter field="TEXT" name="COMMIT_EVERY" value="10000"/>
    <elementParameter field="TEXT" name="LABEL" value="Update etl_job_log"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJDBCRow_13"/>
    <metadata connector="REJECT" name="REJECT">
      <column defaultValue="" key="false" length="255" name="errorCode" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
      <column defaultValue="" key="false" length="255" name="errorMessage" nullable="true" precision="0" sourceType="" type="id_String" usefulColumn="true"/>
    </metadata>
  </node>
  <node componentName="tJDBCClose" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="384" posY="160">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCClose_1"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="COMPONENT_LIST" name="CONNECTION" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
  </node>
  <node componentName="tPostjob" componentVersion="0.102" offsetLabelX="0" offsetLabelY="0" posX="384" posY="32">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tPostjob_1"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
  </node>
  <node componentName="tJava" componentVersion="0.101" offsetLabelX="0" offsetLabelY="0" posX="416" posY="928">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_3"/>
    <elementParameter field="DIRECTORY" name="JAVA_LIBRARY_PATH" value="C:\Talend\Talend-Tools-Studio-20150508_1414-V5.6.2\configuration\lib\java"/>
    <elementParameter field="MEMO_JAVA" name="CODE" value="System.out.println(&quot;Job &quot; + jobName + &quot; is Completed Successfully !&quot;);"/>
    <elementParameter field="MEMO_IMPORT" name="IMPORT" value="//import java.util.List;"/>
    <elementParameter field="TEXT" name="CONNECTION_FORMAT" value="row"/>
    <metadata connector="FLOW" name="tJava_3"/>
  </node>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJava_1" offsetLabelX="0" offsetLabelY="0" source="tJava_1" target="tJava_2">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk15"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCConnection_1" offsetLabelX="0" offsetLabelY="0" source="tJDBCConnection_1" target="tJDBCRow_1">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk1"/>
  </connection>
  <connection connectorName="SUBJOB_OK" label="OnSubjobOk" lineStyle="1" metaname="tJava_2" offsetLabelX="0" offsetLabelY="0" source="tJava_2" target="tJDBCConnection_1">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnSubjobOk1"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_1" offsetLabelX="0" offsetLabelY="0" source="tJDBCRow_1" target="tJDBCRow_2">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk2"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_2" offsetLabelX="0" offsetLabelY="0" outputId="1" source="tJDBCRow_2" target="tJDBCRow_3">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk3"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_2" offsetLabelX="0" offsetLabelY="0" outputId="2" source="tJDBCRow_2" target="tJDBCRow_4">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk4"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_4" offsetLabelX="0" offsetLabelY="0" outputId="1" source="tJDBCRow_4" target="tJDBCRow_5">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk5"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_4" offsetLabelX="0" offsetLabelY="0" outputId="2" source="tJDBCRow_4" target="tJDBCRow_7">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk7"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_5" offsetLabelX="0" offsetLabelY="0" source="tJDBCRow_5" target="tJDBCRow_6">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk6"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_7" offsetLabelX="0" offsetLabelY="0" outputId="1" source="tJDBCRow_7" target="tJDBCRow_8">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk8"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_7" offsetLabelX="0" offsetLabelY="0" outputId="2" source="tJDBCRow_7" target="tJDBCRow_9">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk9"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_9" offsetLabelX="0" offsetLabelY="0" outputId="1" source="tJDBCRow_9" target="tJDBCRow_10">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk10"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_9" offsetLabelX="0" offsetLabelY="0" outputId="2" source="tJDBCRow_9" target="tJDBCRow_11">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk11"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_11" offsetLabelX="0" offsetLabelY="0" outputId="1" source="tJDBCRow_11" target="tJDBCRow_12">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk12"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_11" offsetLabelX="0" offsetLabelY="0" outputId="2" source="tJDBCRow_11" target="tJDBCRow_13">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk13"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tJDBCRow_13" offsetLabelX="0" offsetLabelY="0" source="tJDBCRow_13" target="tJava_3">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk16"/>
  </connection>
  <connection connectorName="COMPONENT_OK" label="OnComponentOk" lineStyle="3" metaname="tPostjob_1" offsetLabelX="0" offsetLabelY="0" source="tPostjob_1" target="tJDBCClose_1">
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="OnComponentOk14"/>
  </connection>
  <note opaque="true" posX="512" posY="512" sizeHeight="97" sizeWidth="257" text="tJDBCRow 5, 6, 8 have ignore nulls.&#xD;&#xA;5  has window workaround&#xD;&#xA;6  and 8 use ignore nulls code"/>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_1"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="Start"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="192;192;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="192;192;192"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCConnection_1"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="Register Connection"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="0;255;0"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="255;255;255"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_2"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="Setting up Connection params"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;128"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="225;225;225"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_1"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="1. Set status BUSY"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="0;128;255"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="251;252;214"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_2"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2a. Delete Overlapping Rows"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;64"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="251;252;214"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_3"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2b. Unload for f_subscriber_activity"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;64"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="251;252;214"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_4"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2c. Delete f_subscriber_status"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;255"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="225;225;225"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_5"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2d. Insert f_subscriber_status"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;255"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="225;225;225"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_6"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2e. Update  f_subscriber_status"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;255"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="225;225;225"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_7"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2f. Full reload of retention fact"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;128"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="255;255;255"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_8"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2f. Insert f_subscriber_retention"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;128"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="255;255;255"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_9"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2g. Delete from f_subscriber_retention_frozen"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="128;255;255"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_10"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2g. Insert f_subscriber_retention_frozen"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="128;128;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="128;255;255"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_11"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2h. Delete from f_subscriber_refund"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="128;255;128"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_12"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="2i. Insert f_subscriber_refund"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="255;128;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="128;255;128"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCRow_13"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="3. Update Status"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="0;128;255"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="251;252;214"/>
  </subjob>
  <subjob>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJDBCClose_1"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="160;190;240"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="220;220;250"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tPostjob_1"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="230;100;0"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="255;220;180"/>
  </subjob>
  <subjob>
    <elementParameter field="CHECK" name="SHOW_SUBJOB_TITLE" value="true"/>
    <elementParameter field="TEXT" name="UNIQUE_NAME" value="tJava_3"/>
    <elementParameter field="TEXT" name="SUBJOB_TITLE" value="Finish"/>
    <elementParameter field="COLOR" name="SUBJOB_TITLE_COLOR" value="192;192;192"/>
    <elementParameter field="COLOR" name="SUBJOB_COLOR" value="192;192;192"/>
  </subjob>
</talendfile:ProcessType>
